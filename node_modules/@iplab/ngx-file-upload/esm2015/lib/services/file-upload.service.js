import { __decorate, __metadata } from "tslib";
import { Injectable, Renderer2 } from '@angular/core';
import { FileUploadTypes } from './../helpers/file-types.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
let FileUploadService = class FileUploadService {
    constructor(renderer) {
        this.renderer = renderer;
        this.extensions = ['B', 'KB', 'MB', 'GB'];
        this.sizeRegex = new RegExp(`^(\\d+)(?:\\s{0,1})(${this.extensions.join('|')})?$`, 'i');
    }
    isFileDragDropAvailable() {
        const div = this.renderer.createElement('div');
        return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div));
    }
    parseSize(value) {
        if (IsNullOrEmpty(value)) {
            return 0;
        }
        if (typeof value === 'number') {
            return value;
        }
        const [, size, extension] = value.match(this.sizeRegex) || [null, '0', 'B'];
        const i = IsNullOrEmpty(extension) ? 0 : this.extensions.indexOf(extension.toUpperCase());
        return parseInt(size, 10) * Math.pow(1024, i < 0 ? 0 : i);
    }
    formatSize(size) {
        return this.calculateSize(size);
    }
    calculateSize(size, extensionIndex = 0) {
        if (isNaN(size)) {
            size = 0;
        }
        if (size < 1024) {
            return `${Math.round(size * 100) / 100} ${this.extensions[extensionIndex]}`;
        }
        return this.calculateSize(size / 1024, extensionIndex + 1);
    }
    getFileType(file) {
        return Object.keys(FileUploadTypes).find((key) => FileUploadTypes[key] === file.type);
    }
};
FileUploadService.ctorParameters = () => [
    { type: Renderer2 }
];
FileUploadService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Renderer2])
], FileUploadService);
export { FileUploadService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BpcGxhYi9uZ3gtZmlsZS11cGxvYWQvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvZmlsZS11cGxvYWQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUszRCxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtJQU0xQixZQUFvQixRQUFtQjtRQUFuQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBSnRCLGVBQVUsR0FBaUIsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVuRCxjQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsdUJBQXVCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFHcEcsQ0FBQztJQUVNLHVCQUF1QjtRQUMxQixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQyxPQUFPLENBQUMsQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksR0FBRyxJQUFJLFFBQVEsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFTSxTQUFTLENBQUMsS0FBc0I7UUFDbkMsSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdEIsT0FBTyxDQUFDLENBQUM7U0FDWjtRQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzNCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsTUFBTSxDQUFDLEVBQUUsSUFBSSxFQUFFLFNBQVMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM1RSxNQUFNLENBQUMsR0FBSSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBVyxDQUFDLENBQUM7UUFFcEcsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVNLFVBQVUsQ0FBQyxJQUFZO1FBQzFCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRU8sYUFBYSxDQUFDLElBQVksRUFBRSxpQkFBeUIsQ0FBQztRQUMxRCxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNiLElBQUksR0FBRyxDQUFDLENBQUM7U0FDWjtRQUVELElBQUksSUFBSSxHQUFHLElBQUksRUFBRTtZQUNiLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO1NBQy9FO1FBRUQsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFTSxXQUFXLENBQUMsSUFBVTtRQUN6QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFGLENBQUM7Q0FDSixDQUFBOztZQTFDaUMsU0FBUzs7QUFOOUIsaUJBQWlCO0lBRDdCLFVBQVUsRUFBRTtxQ0FPcUIsU0FBUztHQU45QixpQkFBaUIsQ0FnRDdCO1NBaERZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkVHlwZXMgfSBmcm9tICcuLy4uL2hlbHBlcnMvZmlsZS10eXBlcy5jbGFzcyc7XHJcbmltcG9ydCB7IElzTnVsbE9yRW1wdHkgfSBmcm9tICcuLy4uL2hlbHBlcnMvaGVscGVycy5jbGFzcyc7XHJcblxyXG5leHBvcnQgdHlwZSBJU2l6ZSA9ICdCJyB8ICdLQicgfCAnTUInIHwgJ0dCJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEZpbGVVcGxvYWRTZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4dGVuc2lvbnM6IEFycmF5PElTaXplPiA9IFsnQicsICdLQicsICdNQicsICdHQiddO1xyXG5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2l6ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXihcXFxcZCspKD86XFxcXHN7MCwxfSkoJHt0aGlzLmV4dGVuc2lvbnMuam9pbignfCcpfSk/JGAsICdpJyk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzRmlsZURyYWdEcm9wQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgcmV0dXJuICgoJ2RyYWdnYWJsZScgaW4gZGl2KSB8fCAoJ29uZHJhZ3N0YXJ0JyBpbiBkaXYgJiYgJ29uZHJvcCcgaW4gZGl2KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHBhcnNlU2l6ZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAoSXNOdWxsT3JFbXB0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBbLCBzaXplLCBleHRlbnNpb25dID0gdmFsdWUubWF0Y2godGhpcy5zaXplUmVnZXgpIHx8IFtudWxsLCAnMCcsICdCJ107XHJcbiAgICAgICAgY29uc3QgaSA9ICBJc051bGxPckVtcHR5KGV4dGVuc2lvbikgPyAwIDogdGhpcy5leHRlbnNpb25zLmluZGV4T2YoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkgYXMgSVNpemUpO1xyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2l6ZSwgMTApICogTWF0aC5wb3coMTAyNCwgaSA8IDAgPyAwIDogaSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZvcm1hdFNpemUoc2l6ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVTaXplKHNpemUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlU2l6ZShzaXplOiBudW1iZXIsIGV4dGVuc2lvbkluZGV4OiBudW1iZXIgPSAwKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoaXNOYU4oc2l6ZSkpIHtcclxuICAgICAgICAgICAgc2l6ZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2l6ZSA8IDEwMjQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQoc2l6ZSAqIDEwMCkgLyAxMDB9ICR7dGhpcy5leHRlbnNpb25zW2V4dGVuc2lvbkluZGV4XX1gO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlU2l6ZShzaXplIC8gMTAyNCwgZXh0ZW5zaW9uSW5kZXggKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RmlsZVR5cGUoZmlsZTogRmlsZSk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKEZpbGVVcGxvYWRUeXBlcykuZmluZCgoa2V5KSA9PiBGaWxlVXBsb2FkVHlwZXNba2V5XSA9PT0gZmlsZS50eXBlKTtcclxuICAgIH1cclxufVxyXG4iXX0=