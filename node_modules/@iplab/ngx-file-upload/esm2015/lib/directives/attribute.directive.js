import { __decorate, __metadata, __param } from "tslib";
import { Directive, Input, Optional, Host, Self } from '@angular/core';
import { FileUploadComponent } from '../components/multiple-file-upload/file-upload.component';
import { SimpleFileUploadComponent } from '../components/simple-file-upload/simple-file-upload.component';
let FilesAcceptDirective = class FilesAcceptDirective {
    constructor(fileUpload, simpleFileUpload) {
        this.fileUpload = null;
        this.fileUpload = fileUpload || simpleFileUpload;
    }
    ngAfterViewInit() {
        this.setAccept(this.accept);
    }
    ngOnChanges(changes) {
        if ('accept' in changes && changes['accept'].currentValue !== changes['accept'].previousValue) {
            this.setAccept(this.accept);
        }
    }
    setAccept(accept) {
        if (this.fileUpload && this.fileUpload.control) {
            this.fileUpload.control.acceptFiles(accept);
        }
    }
};
FilesAcceptDirective.ctorParameters = () => [
    { type: FileUploadComponent, decorators: [{ type: Optional }, { type: Host }, { type: Self }] },
    { type: SimpleFileUploadComponent, decorators: [{ type: Optional }, { type: Host }, { type: Self }] }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], FilesAcceptDirective.prototype, "accept", void 0);
FilesAcceptDirective = __decorate([
    Directive({
        selector: 'file-upload[accept]',
        host: { '[attr.accept]': 'accept ? accept : null' }
    }),
    __param(0, Optional()), __param(0, Host()), __param(0, Self()),
    __param(1, Optional()), __param(1, Host()), __param(1, Self()),
    __metadata("design:paramtypes", [FileUploadComponent,
        SimpleFileUploadComponent])
], FilesAcceptDirective);
export { FilesAcceptDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXR0cmlidXRlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BpcGxhYi9uZ3gtZmlsZS11cGxvYWQvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9hdHRyaWJ1dGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBaUIsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQTRCLE1BQU0sZUFBZSxDQUFDO0FBQ2hILE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBEQUEwRCxDQUFDO0FBQy9GLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLCtEQUErRCxDQUFDO0FBUTFHLElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBTzdCLFlBQ2dDLFVBQStCLEVBQy9CLGdCQUEyQztRQUoxRCxlQUFVLEdBQW9ELElBQUksQ0FBQztRQUtoRixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxnQkFBZ0IsQ0FBQztJQUNyRCxDQUFDO0lBRU0sZUFBZTtRQUNsQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU0sV0FBVyxDQUFDLE9BQXNCO1FBQ3JDLElBQUksUUFBUSxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxLQUFLLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxhQUFhLEVBQUU7WUFDM0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDL0I7SUFDTCxDQUFDO0lBRU8sU0FBUyxDQUFDLE1BQWM7UUFDNUIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFO1lBQzVDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMvQztJQUNMLENBQUM7Q0FDSixDQUFBOztZQXBCK0MsbUJBQW1CLHVCQUExRCxRQUFRLFlBQUksSUFBSSxZQUFJLElBQUk7WUFDcUIseUJBQXlCLHVCQUF0RSxRQUFRLFlBQUksSUFBSSxZQUFJLElBQUk7O0FBTjdCO0lBREMsS0FBSyxFQUFFOztvREFDYztBQUhiLG9CQUFvQjtJQUpoQyxTQUFTLENBQUM7UUFDUCxRQUFRLEVBQUUscUJBQXFCO1FBQy9CLElBQUksRUFBRSxFQUFDLGVBQWUsRUFBRSx3QkFBd0IsRUFBQztLQUNwRCxDQUFDO0lBU08sV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsSUFBSSxFQUFFLENBQUEsRUFBRSxXQUFBLElBQUksRUFBRSxDQUFBO0lBQzFCLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLElBQUksRUFBRSxDQUFBLEVBQUUsV0FBQSxJQUFJLEVBQUUsQ0FBQTtxQ0FEYSxtQkFBbUI7UUFDYix5QkFBeUI7R0FUbEUsb0JBQW9CLENBNEJoQztTQTVCWSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBTaW1wbGVDaGFuZ2VzLCBPcHRpb25hbCwgSG9zdCwgU2VsZiwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZpbGVVcGxvYWRDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzL211bHRpcGxlLWZpbGUtdXBsb2FkL2ZpbGUtdXBsb2FkLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFNpbXBsZUZpbGVVcGxvYWRDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzL3NpbXBsZS1maWxlLXVwbG9hZC9zaW1wbGUtZmlsZS11cGxvYWQuY29tcG9uZW50JztcclxuXHJcblxyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ2ZpbGUtdXBsb2FkW2FjY2VwdF0nLFxyXG4gICAgaG9zdDogeydbYXR0ci5hY2NlcHRdJzogJ2FjY2VwdCA/IGFjY2VwdCA6IG51bGwnfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZXNBY2NlcHREaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgYWNjZXB0OiBzdHJpbmc7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBmaWxlVXBsb2FkOiBGaWxlVXBsb2FkQ29tcG9uZW50IHwgU2ltcGxlRmlsZVVwbG9hZENvbXBvbmVudCA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgQE9wdGlvbmFsKCkgQEhvc3QoKSBAU2VsZigpIGZpbGVVcGxvYWQ6IEZpbGVVcGxvYWRDb21wb25lbnQsXHJcbiAgICAgICAgQE9wdGlvbmFsKCkgQEhvc3QoKSBAU2VsZigpIHNpbXBsZUZpbGVVcGxvYWQ6IFNpbXBsZUZpbGVVcGxvYWRDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLmZpbGVVcGxvYWQgPSBmaWxlVXBsb2FkIHx8IHNpbXBsZUZpbGVVcGxvYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNldEFjY2VwdCh0aGlzLmFjY2VwdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2FjY2VwdCcgaW4gY2hhbmdlcyAmJiBjaGFuZ2VzWydhY2NlcHQnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ2FjY2VwdCddLnByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRBY2NlcHQodGhpcy5hY2NlcHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldEFjY2VwdChhY2NlcHQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGVVcGxvYWQgJiYgdGhpcy5maWxlVXBsb2FkLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlVXBsb2FkLmNvbnRyb2wuYWNjZXB0RmlsZXMoYWNjZXB0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19