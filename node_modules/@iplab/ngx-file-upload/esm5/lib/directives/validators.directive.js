import { __decorate, __metadata } from "tslib";
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { FileUploadValidators } from './../helpers/validators.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import { FileUploadService } from './../services/file-upload.service';
/**
 * A Directive that adds the `filesize` validator to controls marked with the
 * `filesize` attribute. The size of the file is in bytes or any other unit
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel filesize="830000"></file-upload>
 * <file-upload name="files" ngModel [filesize]="830000"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="6200"></file-upload>
 * <file-upload name="files" ngModel filesize="123MB"></file-upload>
 * <file-upload name="files" ngModel [filesize]="12 mb"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="324KB"></file-upload>
 * ```
 *
 */
var FileSizeValidator = /** @class */ (function () {
    function FileSizeValidator(fileUploadService) {
        this.fileUploadService = fileUploadService;
    }
    FileSizeValidator_1 = FileSizeValidator;
    FileSizeValidator.prototype.ngOnChanges = function (changes) {
        if ('filesize' in changes
            || 'maxsize' in changes
            || 'minsize' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    FileSizeValidator.prototype.validate = function (c) {
        return this.validator(c);
    };
    FileSizeValidator.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    FileSizeValidator.prototype._createValidator = function () {
        var maxSize = null;
        if (!IsNullOrEmpty(this.maxsize)) {
            maxSize = this.fileUploadService.parseSize(this.maxsize);
        }
        else if (!IsNullOrEmpty(this.filesize)) {
            maxSize = this.fileUploadService.parseSize(this.filesize);
        }
        var minSize = this.fileUploadService.parseSize(this.minsize);
        this.validator = FileUploadValidators.sizeRange({ maxSize: maxSize, minSize: minSize });
    };
    var FileSizeValidator_1;
    FileSizeValidator.ctorParameters = function () { return [
        { type: FileUploadService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FileSizeValidator.prototype, "filesize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FileSizeValidator.prototype, "minsize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FileSizeValidator.prototype, "maxsize", void 0);
    FileSizeValidator = FileSizeValidator_1 = __decorate([
        Directive({
            selector: "file-upload[filesize][formControlName],\n    file-upload[filesize][formControl],\n    file-upload[filesize][ngModel],\n    file-upload[minsize][formControlName],\n    file-upload[minsize][formControl],\n    file-upload[minsize][ngModel],\n    file-upload[maxsize][formControlName],\n    file-upload[maxsize][formControl],\n    file-upload[maxsize][ngModel]",
            providers: [{
                    provide: NG_VALIDATORS,
                    useExisting: forwardRef(function () { return FileSizeValidator_1; }),
                    multi: true
                }],
            host: {
                '[attr.filesize]': 'filesize ? filesize : null',
                '[attr.minsize]': 'minsize ? minsize : null',
                '[attr.maxsize]': 'maxsize ? maxsize : null'
            }
        }),
        __metadata("design:paramtypes", [FileUploadService])
    ], FileSizeValidator);
    return FileSizeValidator;
}());
export { FileSizeValidator };
/**
 * A Directive that adds the `fileslimit` validator to controls marked with the
 * `fileslimit` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel fileslimit="2"></file-upload>
 * <file-upload name="files" ngModel [fileslimit]="2"></file-upload>
 * ```
 *
 */
var FilesLimitValidator = /** @class */ (function () {
    function FilesLimitValidator() {
    }
    FilesLimitValidator_1 = FilesLimitValidator;
    FilesLimitValidator.prototype.ngOnChanges = function (changes) {
        if ('fileslimit' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    FilesLimitValidator.prototype.validate = function (c) {
        return this.fileslimit != null ? this.validator(c) : null;
    };
    FilesLimitValidator.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    FilesLimitValidator.prototype._createValidator = function () {
        this.validator = FileUploadValidators.filesLimit(typeof this.fileslimit === 'string' ? parseInt(this.fileslimit, 10) : this.fileslimit);
    };
    var FilesLimitValidator_1;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FilesLimitValidator.prototype, "fileslimit", void 0);
    FilesLimitValidator = FilesLimitValidator_1 = __decorate([
        Directive({
            selector: 'file-upload[fileslimit][formControlName], file-upload[fileslimit][formControl], file-upload[fileslimit][ngModel]',
            providers: [{
                    provide: NG_VALIDATORS,
                    useExisting: forwardRef(function () { return FilesLimitValidator_1; }),
                    multi: true
                }],
            host: { '[attr.fileslimit]': 'fileslimit ? fileslimit : null' }
        })
    ], FilesLimitValidator);
    return FilesLimitValidator;
}());
export { FilesLimitValidator };
/**
 * A Directive that adds the `accept` validator to controls marked with the
 * `accept` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel accept="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * <file-upload name="files" ngModel [accept]="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * ```
 *
 * To specify more than one value, separate the values with a comma (e.g. <file-upload accept="audio/*,video/*,image/*"></file-upload>.
 *
 */
var FilesAcceptValidator = /** @class */ (function () {
    function FilesAcceptValidator() {
    }
    FilesAcceptValidator_1 = FilesAcceptValidator;
    FilesAcceptValidator.prototype.ngOnChanges = function (changes) {
        if ('accept' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    };
    FilesAcceptValidator.prototype.validate = function (c) {
        return !!this.validator ? this.validator(c) : null;
    };
    FilesAcceptValidator.prototype.registerOnValidatorChange = function (fn) {
        this.onChange = fn;
    };
    FilesAcceptValidator.prototype._createValidator = function () {
        if (IsNullOrEmpty(this.accept)) {
            return;
        }
        this.validator = FileUploadValidators.accept(this.accept.split(','));
    };
    var FilesAcceptValidator_1;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FilesAcceptValidator.prototype, "accept", void 0);
    FilesAcceptValidator = FilesAcceptValidator_1 = __decorate([
        Directive({
            selector: 'file-upload[accept][formControlName], file-upload[accept][formControl], file-upload[accept][ngModel]',
            providers: [{
                    provide: NG_VALIDATORS,
                    useExisting: forwardRef(function () { return FilesAcceptValidator_1; }),
                    multi: true
                }],
            host: { '[attr.accept]': 'accept ? accept : null' }
        })
    ], FilesAcceptValidator);
    return FilesAcceptValidator;
}());
export { FilesAcceptValidator };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaXBsYWIvbmd4LWZpbGUtdXBsb2FkLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBK0QsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFFLGFBQWEsRUFBOEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQWlDLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBR3RFOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQXNCSDtJQWFJLDJCQUE2QixpQkFBb0M7UUFBcEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtJQUFFLENBQUM7MEJBYjNELGlCQUFpQjtJQWlCbkIsdUNBQVcsR0FBbEIsVUFBbUIsT0FBc0I7UUFDckMsSUFBSSxVQUFVLElBQUksT0FBTztlQUNsQixTQUFTLElBQUksT0FBTztlQUNwQixTQUFTLElBQUksT0FBTyxFQUFFO1lBQzNCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDZixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDbkI7U0FDRjtJQUNMLENBQUM7SUFFTSxvQ0FBUSxHQUFmLFVBQWdCLENBQWtCO1FBQzlCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRU0scURBQXlCLEdBQWhDLFVBQWlDLEVBQWM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVPLDRD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LEVBQUUsYUFBYTtvQkFDdEIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxjQUFNLE9BQUEsc0JBQW9CLEVBQXBCLENBQW9CLENBQUM7b0JBQ25ELEtBQUssRUFBRSxJQUFJO2lCQUNkLENBQUM7WUFDRixJQUFJLEVBQUUsRUFBQyxlQUFlLEVBQUUsd0JBQXdCLEVBQUM7U0FDcEQsQ0FBQztPQUNXLG9CQUFvQixDQWdDaEM7SUFBRCwyQkFBQztDQUFBLEFBaENELElBZ0NDO1NBaENZLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgSG9zdCwgU2VsZiwgT3B0aW9uYWwsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgQWJzdHJhY3RDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiwgRmlsZVVwbG9hZFZhbGlkYXRvcnMgfSBmcm9tICcuLy4uL2hlbHBlcnMvdmFsaWRhdG9ycy5jbGFzcyc7XHJcbmltcG9ydCB7IElzTnVsbE9yRW1wdHkgfSBmcm9tICcuLy4uL2hlbHBlcnMvaGVscGVycy5jbGFzcyc7XHJcbmltcG9ydCB7IEZpbGVVcGxvYWRTZXJ2aWNlIH0gZnJvbSAnLi8uLi9zZXJ2aWNlcy9maWxlLXVwbG9hZC5zZXJ2aWNlJztcclxuXHJcblxyXG4vKipcclxuICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgZmlsZXNpemVgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcclxuICogYGZpbGVzaXplYCBhdHRyaWJ1dGUuIFRoZSBzaXplIG9mIHRoZSBmaWxlIGlzIGluIGJ5dGVzIG9yIGFueSBvdGhlciB1bml0XHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBmaWxlc2l6ZT1cIjgzMDAwMFwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFtmaWxlc2l6ZV09XCI4MzAwMDBcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBtaW5TaXplPVwiMFwiIG1heD1cIjYyMDBcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBmaWxlc2l6ZT1cIjEyM01CXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2ZpbGVzaXplXT1cIjEyIG1iXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgbWluU2l6ZT1cIjBcIiBtYXg9XCIzMjRLQlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogYGZpbGUtdXBsb2FkW2ZpbGVzaXplXVtmb3JtQ29udHJvbE5hbWVdLFxyXG4gICAgZmlsZS11cGxvYWRbZmlsZXNpemVdW2Zvcm1Db250cm9sXSxcclxuICAgIGZpbGUtdXBsb2FkW2ZpbGVzaXplXVtuZ01vZGVsXSxcclxuICAgIGZpbGUtdXBsb2FkW21pbnNpemVdW2Zvcm1Db250cm9sTmFtZV0sXHJcbiAgICBmaWxlLXVwbG9hZFttaW5zaXplXVtmb3JtQ29udHJvbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttaW5zaXplXVtuZ01vZGVsXSxcclxuICAgIGZpbGUtdXBsb2FkW21heHNpemVdW2Zvcm1Db250cm9sTmFtZV0sXHJcbiAgICBmaWxlLXVwbG9hZFttYXhzaXplXVtmb3JtQ29udHJvbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttYXhzaXplXVtuZ01vZGVsXWAsXHJcbiAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGaWxlU2l6ZVZhbGlkYXRvciksXHJcbiAgICAgICAgbXVsdGk6IHRydWVcclxuICAgIH1dLFxyXG4gICAgaG9zdDoge1xyXG4gICAgICAgICdbYXR0ci5maWxlc2l6ZV0nOiAnZmlsZXNpemUgPyBmaWxlc2l6ZSA6IG51bGwnLFxyXG4gICAgICAgICdbYXR0ci5taW5zaXplXSc6ICdtaW5zaXplID8gbWluc2l6ZSA6IG51bGwnLFxyXG4gICAgICAgICdbYXR0ci5tYXhzaXplXSc6ICdtYXhzaXplID8gbWF4c2l6ZSA6IG51bGwnXHJcbiAgICB9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGaWxlU2l6ZVZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGZpbGVzaXplOiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgbWluc2l6ZTogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIG1heHNpemU6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZmlsZVVwbG9hZFNlcnZpY2U6IEZpbGVVcGxvYWRTZXJ2aWNlKXt9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmICgnZmlsZXNpemUnIGluIGNoYW5nZXMgXHJcbiAgICAgICAgICAgIHx8ICdtYXhzaXplJyBpbiBjaGFuZ2VzIFxyXG4gICAgICAgICAgICB8fCAnbWluc2l6ZScgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnN8bnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKGMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuOyBcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jcmVhdGVWYWxpZGF0b3IoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IG1heFNpemUgPSBudWxsO1xyXG4gICAgICAgIGlmICghSXNOdWxsT3JFbXB0eSh0aGlzLm1heHNpemUpKSB7XHJcbiAgICAgICAgICAgIG1heFNpemUgPSB0aGlzLmZpbGVVcGxvYWRTZXJ2aWNlLnBhcnNlU2l6ZSh0aGlzLm1heHNpemUpO1xyXG4gICAgICAgIH0gZWxzZSBpZighSXNOdWxsT3JFbXB0eSh0aGlzLmZpbGVzaXplKSkge1xyXG4gICAgICAgICAgICBtYXhTaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5maWxlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtaW5TaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5taW5zaXplKTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLnNpemVSYW5nZSh7IG1heFNpemUsIG1pblNpemUgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgZmlsZXNsaW1pdGAgdmFsaWRhdG9yIHRvIGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxyXG4gKiBgZmlsZXNsaW1pdGAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNsaW1pdD1cIjJcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNsaW1pdF09XCIyXCI+PC9maWxlLXVwbG9hZD5cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnZmlsZS11cGxvYWRbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xOYW1lXSwgZmlsZS11cGxvYWRbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xdLCBmaWxlLXVwbG9hZFtmaWxlc2xpbWl0XVtuZ01vZGVsXScsXHJcbiAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGaWxlc0xpbWl0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmZpbGVzbGltaXRdJzogJ2ZpbGVzbGltaXQgPyBmaWxlc2xpbWl0IDogbnVsbCd9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGaWxlc0xpbWl0VmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZmlsZXNsaW1pdDogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmICgnZmlsZXNsaW1pdCcgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzbGltaXQgIT0gbnVsbCA/IHRoaXMudmFsaWRhdG9yKGMpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjsgXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gRmlsZVVwbG9hZFZhbGlkYXRvcnMuZmlsZXNMaW1pdCh0eXBlb2YgdGhpcy5maWxlc2xpbWl0ID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHRoaXMuZmlsZXNsaW1pdCwgMTApIDogdGhpcy5maWxlc2xpbWl0KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGFjY2VwdGAgdmFsaWRhdG9yIHRvIGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxyXG4gKiBgYWNjZXB0YCBhdHRyaWJ1dGUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBhY2NlcHQ9XCJmaWxlX2V4dGVuc2lvbnxhdWRpby8qfHZpZGVvLyp8aW1hZ2UvKnxtZWRpYV90eXBlXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2FjY2VwdF09XCJmaWxlX2V4dGVuc2lvbnxhdWRpby8qfHZpZGVvLyp8aW1hZ2UvKnxtZWRpYV90eXBlXCI+PC9maWxlLXVwbG9hZD5cclxuICogYGBgXHJcbiAqIFxyXG4gKiBUbyBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgdmFsdWUsIHNlcGFyYXRlIHRoZSB2YWx1ZXMgd2l0aCBhIGNvbW1hIChlLmcuIDxmaWxlLXVwbG9hZCBhY2NlcHQ9XCJhdWRpby8qLHZpZGVvLyosaW1hZ2UvKlwiPjwvZmlsZS11cGxvYWQ+LlxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ2ZpbGUtdXBsb2FkW2FjY2VwdF1bZm9ybUNvbnRyb2xOYW1lXSwgZmlsZS11cGxvYWRbYWNjZXB0XVtmb3JtQ29udHJvbF0sIGZpbGUtdXBsb2FkW2FjY2VwdF1bbmdNb2RlbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZXNBY2NlcHRWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHsnW2F0dHIuYWNjZXB0XSc6ICdhY2NlcHQgPyBhY2NlcHQgOiBudWxsJ31cclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVzQWNjZXB0VmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgYWNjZXB0OiBzdHJpbmc7XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2FjY2VwdCcgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnN8bnVsbCB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy52YWxpZGF0b3IgPyB0aGlzLnZhbGlkYXRvcihjKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChJc051bGxPckVtcHR5KHRoaXMuYWNjZXB0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gRmlsZVVwbG9hZFZhbGlkYXRvcnMuYWNjZXB0KHRoaXMuYWNjZXB0LnNwbGl0KCcsJykpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==