{"ast":null,"code":"import _classCallCheck from \"/Users/pillaga/Documents/Angular Projects/horux/adminPrueba/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/pillaga/Documents/Angular Projects/horux/adminPrueba/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Directive, ElementRef, Inject, HostBinding, Input, EventEmitter, Component, Renderer2, ViewChild, ContentChildren, Output, HostListener, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nvar _c0 = [\"contentRef\"];\nvar _c1 = [\"*\"];\n\nvar DragScrollItemDirective = /*@__PURE__*/function () {\n  var DragScrollItemDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} elementRef\n     */\n    function DragScrollItemDirective(elementRef) {\n      _classCallCheck(this, DragScrollItemDirective);\n\n      this.display = 'inline-block';\n      this._dragDisabled = false;\n      this._elementRef = elementRef;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DragScrollItemDirective, [{\n      key: \"dragDisabled\",\n      get: function get() {\n        return this._dragDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._dragDisabled = value;\n      }\n    }]);\n\n    return DragScrollItemDirective;\n  }();\n\n  DragScrollItemDirective.ɵfac = function DragScrollItemDirective_Factory(t) {\n    return new (t || DragScrollItemDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef));\n  };\n\n  DragScrollItemDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragScrollItemDirective,\n    selectors: [[\"\", \"drag-scroll-item\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DragScrollItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.display);\n      }\n    },\n    inputs: {\n      dragDisabled: [\"drag-disabled\", \"dragDisabled\"]\n    }\n  });\n  return DragScrollItemDirective;\n}();\n\nvar DragScrollComponent = /*@__PURE__*/function () {\n  var DragScrollComponent = /*#__PURE__*/function () {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     * @param {?} _document\n     */\n    function DragScrollComponent(_elementRef, _renderer, _document) {\n      _classCallCheck(this, DragScrollComponent);\n\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._document = _document;\n      this._index = 0;\n      this._scrollbarHidden = false;\n      this._disabled = false;\n      this._xDisabled = false;\n      this._xWheelEnabled = false;\n      this._yDisabled = false;\n      this._dragDisabled = false;\n      this._snapDisabled = false;\n      this._snapOffset = 0;\n      this._snapDuration = 500;\n      this._isDragging = false;\n      /**\n       * Is the user currently pressing the element\n       */\n\n      this.isPressed = false;\n      /**\n       * Is the user currently scrolling the element\n       */\n\n      this.isScrolling = false;\n      this.scrollTimer = -1;\n      this.scrollToTimer = -1;\n      /**\n       * The x coordinates on the element\n       */\n\n      this.downX = 0;\n      /**\n       * The y coordinates on the element\n       */\n\n      this.downY = 0;\n      this.displayType = 'block';\n      this.elWidth = null;\n      this.elHeight = null;\n      this._pointerEvents = 'auto';\n      this.scrollbarWidth = null;\n      this.isAnimating = false;\n      this.prevChildrenLength = 0;\n      this.indexBound = 0;\n      this.dsInitialized = new EventEmitter();\n      this.indexChanged = new EventEmitter();\n      this.reachesLeftBound = new EventEmitter();\n      this.reachesRightBound = new EventEmitter();\n      this.snapAnimationFinished = new EventEmitter();\n      this.dragStart = new EventEmitter();\n      this.dragEnd = new EventEmitter();\n      this.scrollbarWidth = \"\".concat(this.getScrollbarWidth(), \"px\");\n    }\n    /**\n     * Is the user currently dragging the element\n     * @return {?}\n     */\n\n\n    _createClass(DragScrollComponent, [{\n      key: \"isDragging\",\n      get: function get() {\n        return this._isDragging;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"currIndex\",\n      get: function get() {\n        return this._index;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        if (value !== this._index) {\n          this._index = value;\n          this.indexChanged.emit(value);\n        }\n      }\n      /**\n       * Whether the scrollbar is hidden\n       * @return {?}\n       */\n\n    }, {\n      key: \"scrollbarHidden\",\n      get: function get() {\n        return this._scrollbarHidden;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._scrollbarHidden = value;\n      }\n      /**\n       * Whether horizontally and vertically draging and scrolling is be disabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"disabled\",\n      get: function get() {\n        return this._disabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._disabled = value;\n      }\n      /**\n       * Whether horizontally dragging and scrolling is be disabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"xDisabled\",\n      get: function get() {\n        return this._xDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._xDisabled = value;\n      }\n      /**\n       * Whether vertically dragging and scrolling events is disabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"yDisabled\",\n      get: function get() {\n        return this._yDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._yDisabled = value;\n      }\n      /**\n       * Whether scrolling horizontally with mouse wheel is enabled\n       * @return {?}\n       */\n\n    }, {\n      key: \"xWheelEnabled\",\n      get: function get() {\n        return this._xWheelEnabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._xWheelEnabled = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"dragDisabled\",\n      get: function get() {\n        return this._dragDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._dragDisabled = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"snapDisabled\",\n      get: function get() {\n        return this._snapDisabled;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._snapDisabled = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"snapOffset\",\n      get: function get() {\n        return this._snapOffset;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._snapOffset = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"snapDuration\",\n      get: function get() {\n        return this._snapDuration;\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this._snapDuration = value;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.setScrollBar();\n\n        if (this.xDisabled || this.disabled) {\n          this.disableScroll('x');\n        } else {\n          this.enableScroll('x');\n        }\n\n        if (this.yDisabled || this.disabled) {\n          this.disableScroll('y');\n        } else {\n          this.enableScroll('y');\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        // auto assign computed css\n        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'true');\n\n        this.displayType = typeof window !== 'undefined' ? window.getComputedStyle(this._elementRef.nativeElement).display : 'block';\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'display', this.displayType);\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'whiteSpace', 'noWrap'); // store ele width height for later user\n\n\n        this.markElDimension();\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', this.elWidth);\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.elHeight);\n\n        if (this.wrapper) {\n          this.checkScrollbar();\n        }\n\n        this._onMouseDownListener = this._renderer.listen(this._contentRef.nativeElement, 'mousedown', this.onMouseDownHandler.bind(this));\n        this._onScrollListener = this._renderer.listen(this._contentRef.nativeElement, 'scroll', this.onScrollHandler.bind(this)); // prevent Firefox from dragging images\n\n        this._onDragStartListener = this._renderer.listen('document', 'dragstart',\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        function (e) {\n          e.preventDefault();\n        });\n        this.checkNavStatus();\n        this.dsInitialized.emit();\n        this.adjustMarginToLastChild();\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngAfterViewChecked\",\n      value: function ngAfterViewChecked() {\n        // avoid extra checks\n        if (this._children['_results'].length !== this.prevChildrenLength) {\n          this.markElDimension();\n          this.checkScrollbar();\n          this.prevChildrenLength = this._children['_results'].length;\n          this.checkNavStatus();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'false');\n\n        if (this._onMouseDownListener) {\n          this._onMouseDownListener = this._onMouseDownListener();\n        }\n\n        if (this._onScrollListener) {\n          this._onScrollListener = this._onScrollListener();\n        }\n\n        if (this._onDragStartListener) {\n          this._onDragStartListener = this._onDragStartListener();\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseMoveHandler\",\n      value: function onMouseMoveHandler(event) {\n        this.onMouseMove(event);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseMove\",\n      value: function onMouseMove(event) {\n        if (this.isPressed && !this.disabled) {\n          // Workaround for prevent scroll stuck if browser lost focus\n          // MouseEvent.buttons not support by Safari\n          // tslint:disable-next-line:deprecation\n          if (!event.buttons && !event.which) {\n            return this.onMouseUpHandler(event);\n          }\n\n          this._pointerEvents = 'none';\n\n          this._setIsDragging(true); // Drag X\n\n\n          if (!this.xDisabled && !this.dragDisabled) {\n            /** @type {?} */\n            var clientX =\n            /** @type {?} */\n            event.clientX;\n            this._contentRef.nativeElement.scrollLeft = this._contentRef.nativeElement.scrollLeft - clientX + this.downX;\n            this.downX = clientX;\n          } // Drag Y\n\n\n          if (!this.yDisabled && !this.dragDisabled) {\n            /** @type {?} */\n            var clientY =\n            /** @type {?} */\n            event.clientY;\n            this._contentRef.nativeElement.scrollTop = this._contentRef.nativeElement.scrollTop - clientY + this.downY;\n            this.downY = clientY;\n          }\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseDownHandler\",\n      value: function onMouseDownHandler(event) {\n        /** @type {?} */\n        var dragScrollItem = this.locateDragScrollItem(\n        /** @type {?} */\n        event.target);\n\n        if (dragScrollItem && dragScrollItem.dragDisabled) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var isTouchEvent = event.type === 'touchstart';\n\n        this._startGlobalListening(isTouchEvent);\n\n        this.isPressed = true;\n        /** @type {?} */\n\n        var mouseEvent =\n        /** @type {?} */\n        event;\n        this.downX = mouseEvent.clientX;\n        this.downY = mouseEvent.clientY;\n        clearTimeout(\n        /** @type {?} */\n        this.scrollToTimer);\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onScrollHandler\",\n      value: function onScrollHandler() {\n        var _this = this;\n\n        this.checkNavStatus();\n\n        if (!this.isPressed && !this.isAnimating && !this.snapDisabled) {\n          this.isScrolling = true;\n          clearTimeout(\n          /** @type {?} */\n          this.scrollTimer);\n          this.scrollTimer = setTimeout(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this.isScrolling = false;\n\n            _this.locateCurrentIndex(true);\n          }, 500);\n        } else {\n          this.locateCurrentIndex();\n        }\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseUpHandler\",\n      value: function onMouseUpHandler(event) {\n        if (this.isPressed) {\n          this.isPressed = false;\n          this._pointerEvents = 'auto';\n\n          this._setIsDragging(false);\n\n          if (!this.snapDisabled) {\n            this.locateCurrentIndex(true);\n          } else {\n            this.locateCurrentIndex();\n          }\n\n          this._stopGlobalListening();\n        }\n      }\n      /*\n         * Nav button\n         */\n\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"moveLeft\",\n      value: function moveLeft() {\n        if (this.currIndex !== 0 || this.snapDisabled) {\n          this.currIndex--;\n          clearTimeout(\n          /** @type {?} */\n          this.scrollToTimer);\n          this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"moveRight\",\n      value: function moveRight() {\n        /** @type {?} */\n        var container = this.wrapper || this.parentNode;\n        /** @type {?} */\n\n        var containerWidth = container ? container.clientWidth : 0;\n\n        if (!this.isScrollReachesRightEnd() && this.currIndex < this.maximumIndex(containerWidth, this._children)) {\n          this.currIndex++;\n          clearTimeout(\n          /** @type {?} */\n          this.scrollToTimer);\n          this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n        }\n      }\n      /**\n       * @param {?} index\n       * @return {?}\n       */\n\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(index) {\n        /** @type {?} */\n        var container = this.wrapper || this.parentNode;\n        /** @type {?} */\n\n        var containerWidth = container ? container.clientWidth : 0;\n\n        if (index >= 0 && index !== this.currIndex && this.currIndex <= this.maximumIndex(containerWidth, this._children)) {\n          this.currIndex = Math.min(index, this.maximumIndex(containerWidth, this._children));\n          clearTimeout(\n          /** @type {?} */\n          this.scrollToTimer);\n          this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkNavStatus\",\n      value: function checkNavStatus() {\n        var _this2 = this;\n\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          /** @type {?} */\n          var onlyOneItem = Boolean(_this2._children['_results'].length <= 1);\n          /** @type {?} */\n\n          var containerIsLargerThanContent = Boolean(_this2._contentRef.nativeElement.scrollWidth <= _this2._contentRef.nativeElement.clientWidth);\n\n          if (onlyOneItem || containerIsLargerThanContent) {\n            // only one element\n            _this2.reachesLeftBound.emit(true);\n\n            _this2.reachesRightBound.emit(true);\n          } else if (_this2.isScrollReachesRightEnd()) {\n            // reached right end\n            _this2.reachesLeftBound.emit(false);\n\n            _this2.reachesRightBound.emit(true);\n          } else if (_this2._contentRef.nativeElement.scrollLeft === 0 && _this2._contentRef.nativeElement.scrollWidth > _this2._contentRef.nativeElement.clientWidth) {\n            // reached left end\n            _this2.reachesLeftBound.emit(true);\n\n            _this2.reachesRightBound.emit(false);\n          } else {\n            // in the middle\n            _this2.reachesLeftBound.emit(false);\n\n            _this2.reachesRightBound.emit(false);\n          }\n        }, 0);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onWheel\",\n      value: function onWheel(event) {\n        if (this._xWheelEnabled) {\n          event.preventDefault();\n\n          if (this._snapDisabled) {\n            this._contentRef.nativeElement.scrollBy(event.deltaY, 0);\n          } else {\n            if (event.deltaY < 0) {\n              this.moveLeft();\n            } else if (event.deltaY > 0) {\n              this.moveRight();\n            }\n          }\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"onWindowResize\",\n      value: function onWindowResize() {\n        this.refreshWrapperDimensions();\n      }\n      /**\n       * @private\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setIsDragging\",\n      value: function _setIsDragging(value) {\n        if (this._isDragging === value) {\n          return;\n        }\n\n        this._isDragging = value;\n        value ? this.dragStart.emit() : this.dragEnd.emit();\n      }\n      /**\n       * @private\n       * @param {?} isTouchEvent\n       * @return {?}\n       */\n\n    }, {\n      key: \"_startGlobalListening\",\n      value: function _startGlobalListening(isTouchEvent) {\n        if (!this._onMouseMoveListener) {\n          /** @type {?} */\n          var eventName = isTouchEvent ? 'touchmove' : 'mousemove';\n          this._onMouseMoveListener = this._renderer.listen('document', eventName, this.onMouseMoveHandler.bind(this));\n        }\n\n        if (!this._onMouseUpListener) {\n          /** @type {?} */\n          var _eventName = isTouchEvent ? 'touchend' : 'mouseup';\n\n          this._onMouseUpListener = this._renderer.listen('document', _eventName, this.onMouseUpHandler.bind(this));\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"_stopGlobalListening\",\n      value: function _stopGlobalListening() {\n        if (this._onMouseMoveListener) {\n          this._onMouseMoveListener = this._onMouseMoveListener();\n        }\n\n        if (this._onMouseUpListener) {\n          this._onMouseUpListener = this._onMouseUpListener();\n        }\n      }\n      /**\n       * @private\n       * @param {?} axis\n       * @return {?}\n       */\n\n    }, {\n      key: \"disableScroll\",\n      value: function disableScroll(axis) {\n        this._renderer.setStyle(this._contentRef.nativeElement, \"overflow-\".concat(axis), 'hidden');\n      }\n      /**\n       * @private\n       * @param {?} axis\n       * @return {?}\n       */\n\n    }, {\n      key: \"enableScroll\",\n      value: function enableScroll(axis) {\n        this._renderer.setStyle(this._contentRef.nativeElement, \"overflow-\".concat(axis), 'auto');\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"hideScrollbar\",\n      value: function hideScrollbar() {\n        if (this._contentRef.nativeElement.style.display !== 'none' && !this.wrapper) {\n          this.parentNode = this._contentRef.nativeElement.parentNode; // create container element\n\n          this.wrapper = this._renderer.createElement('div');\n\n          this._renderer.setAttribute(this.wrapper, 'class', 'drag-scroll-wrapper');\n\n          this._renderer.addClass(this.wrapper, 'drag-scroll-container');\n\n          this.refreshWrapperDimensions();\n\n          this._renderer.setStyle(this.wrapper, 'overflow', 'hidden');\n\n          this._renderer.setStyle(this._contentRef.nativeElement, 'width', \"calc(100% + \".concat(this.scrollbarWidth, \")\"));\n\n          this._renderer.setStyle(this._contentRef.nativeElement, 'height', \"calc(100% + \".concat(this.scrollbarWidth, \")\")); // Append container element to component element.\n\n\n          this._renderer.appendChild(this._elementRef.nativeElement, this.wrapper); // Append content element to container element.\n\n\n          this._renderer.appendChild(this.wrapper, this._contentRef.nativeElement);\n\n          this.adjustMarginToLastChild();\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"showScrollbar\",\n      value: function showScrollbar() {\n        if (this.wrapper) {\n          this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n\n          this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.wrapper.style.height);\n\n          if (this.parentNode !== null) {\n            this.parentNode.removeChild(this.wrapper);\n            this.parentNode.appendChild(this._contentRef.nativeElement);\n          }\n\n          this.wrapper = null;\n          this.adjustMarginToLastChild();\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkScrollbar\",\n      value: function checkScrollbar() {\n        if (this._contentRef.nativeElement.scrollWidth <= this._contentRef.nativeElement.clientWidth) {\n          this._renderer.setStyle(this._contentRef.nativeElement, 'height', '100%');\n        } else {\n          this._renderer.setStyle(this._contentRef.nativeElement, 'height', \"calc(100% + \".concat(this.scrollbarWidth, \")\"));\n        }\n\n        if (this._contentRef.nativeElement.scrollHeight <= this._contentRef.nativeElement.clientHeight) {\n          this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n        } else {\n          this._renderer.setStyle(this._contentRef.nativeElement, 'width', \"calc(100% + \".concat(this.scrollbarWidth, \")\"));\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"setScrollBar\",\n      value: function setScrollBar() {\n        if (this.scrollbarHidden) {\n          this.hideScrollbar();\n        } else {\n          this.showScrollbar();\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getScrollbarWidth\",\n      value: function getScrollbarWidth() {\n        /**\n         * Browser Scrollbar Widths (2016)\n         * OSX (Chrome, Safari, Firefox) - 15px\n         * Windows XP (IE7, Chrome, Firefox) - 17px\n         * Windows 7 (IE10, IE11, Chrome, Firefox) - 17px\n         * Windows 8.1 (IE11, Chrome, Firefox) - 17px\n         * Windows 10 (IE11, Chrome, Firefox) - 17px\n         * Windows 10 (Edge 12/13) - 12px\n         * @type {?}\n         */\n        var outer = this._renderer.createElement('div');\n\n        this._renderer.setStyle(outer, 'visibility', 'hidden');\n\n        this._renderer.setStyle(outer, 'width', '100px');\n\n        this._renderer.setStyle(outer, 'msOverflowStyle', 'scrollbar'); // needed for WinJS apps\n        // document.body.appendChild(outer);\n\n\n        this._renderer.appendChild(this._document.body, outer); // this._renderer.appendChild(this._renderer.selectRootElement('body'), outer);\n\n        /** @type {?} */\n\n\n        var widthNoScroll = outer.offsetWidth; // force scrollbars\n\n        this._renderer.setStyle(outer, 'overflow', 'scroll'); // add innerdiv\n\n        /** @type {?} */\n\n\n        var inner = this._renderer.createElement('div');\n\n        this._renderer.setStyle(inner, 'width', '100%');\n\n        this._renderer.appendChild(outer, inner);\n        /** @type {?} */\n\n\n        var widthWithScroll = inner.offsetWidth; // remove divs\n\n        this._renderer.removeChild(this._document.body, outer);\n        /**\n         * Scrollbar width will be 0 on Mac OS with the\n         * default \"Only show scrollbars when scrolling\" setting (Yosemite and up).\n         * setting default width to 20;\n         */\n\n\n        return widthNoScroll - widthWithScroll || 20;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"refreshWrapperDimensions\",\n      value: function refreshWrapperDimensions() {\n        if (this.wrapper) {\n          this._renderer.setStyle(this.wrapper, 'width', '100%');\n\n          this._renderer.setStyle(this.wrapper, 'height', this._elementRef.nativeElement.style.height || this._elementRef.nativeElement.offsetHeight + 'px');\n        }\n      }\n      /*\n        * The below solution is heavily inspired from\n        * https://gist.github.com/andjosh/6764939\n        */\n\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} to\n       * @param {?} duration\n       * @return {?}\n       */\n\n    }, {\n      key: \"scrollTo\",\n      value: function scrollTo(element, to, duration) {\n        /** @type {?} */\n        var self = this;\n        self.isAnimating = true;\n        /** @type {?} */\n\n        var start = element.scrollLeft;\n        /** @type {?} */\n\n        var change = to - start - this.snapOffset;\n        /** @type {?} */\n\n        var increment = 20;\n        /** @type {?} */\n\n        var currentTime = 0; // t = current time\n        // b = start value\n        // c = change in value\n        // d = duration\n\n        /** @type {?} */\n\n        var easeInOutQuad =\n        /**\n        * @param {?} t\n        * @param {?} b\n        * @param {?} c\n        * @param {?} d\n        * @return {?}\n        */\n        function easeInOutQuad(t, b, c, d) {\n          t /= d / 2;\n\n          if (t < 1) {\n            return c / 2 * t * t + b;\n          }\n\n          t--;\n          return -c / 2 * (t * (t - 2) - 1) + b;\n        };\n        /** @type {?} */\n\n\n        var animateScroll =\n        /**\n        * @return {?}\n        */\n        function animateScroll() {\n          currentTime += increment;\n          element.scrollLeft = easeInOutQuad(currentTime, start, change, duration);\n\n          if (currentTime < duration) {\n            self.scrollToTimer = setTimeout(animateScroll, increment);\n          } else {\n            // run one more frame to make sure the animation is fully finished\n            setTimeout(\n            /**\n            * @return {?}\n            */\n            function () {\n              self.isAnimating = false;\n              self.snapAnimationFinished.emit(self.currIndex);\n            }, increment);\n          }\n        };\n\n        animateScroll();\n      }\n      /**\n       * @private\n       * @param {?=} snap\n       * @return {?}\n       */\n\n    }, {\n      key: \"locateCurrentIndex\",\n      value: function locateCurrentIndex(snap) {\n        var _this3 = this;\n\n        this.currentChildWidth(\n        /**\n        * @param {?} currentChildWidth\n        * @param {?} nextChildrenWidth\n        * @param {?} childrenWidth\n        * @param {?} idx\n        * @param {?} stop\n        * @return {?}\n        */\n        function (currentChildWidth, nextChildrenWidth, childrenWidth, idx, stop) {\n          if (_this3._contentRef.nativeElement.scrollLeft >= childrenWidth && _this3._contentRef.nativeElement.scrollLeft <= nextChildrenWidth) {\n            if (nextChildrenWidth - _this3._contentRef.nativeElement.scrollLeft > currentChildWidth / 2 && !_this3.isScrollReachesRightEnd()) {\n              // roll back scrolling\n              if (!_this3.isAnimating) {\n                _this3.currIndex = idx;\n              }\n\n              if (snap) {\n                _this3.scrollTo(_this3._contentRef.nativeElement, childrenWidth, _this3.snapDuration);\n              }\n            } else if (_this3._contentRef.nativeElement.scrollLeft !== 0) {\n              // forward scrolling\n              if (!_this3.isAnimating) {\n                _this3.currIndex = idx + 1;\n              }\n\n              if (snap) {\n                _this3.scrollTo(_this3._contentRef.nativeElement, childrenWidth + currentChildWidth, _this3.snapDuration);\n              }\n            }\n\n            stop();\n          } else if (idx + 1 === _this3._children['_results'].length - 1) {\n            // reaches last index\n            if (!_this3.isAnimating) {\n              _this3.currIndex = idx + 1;\n            }\n\n            stop();\n          }\n        });\n      }\n      /**\n       * @private\n       * @param {?} cb\n       * @return {?}\n       */\n\n    }, {\n      key: \"currentChildWidth\",\n      value: function currentChildWidth(cb) {\n        /** @type {?} */\n        var childrenWidth = 0;\n        /** @type {?} */\n\n        var shouldBreak = false;\n        /** @type {?} */\n\n        var breakFunc =\n        /**\n        * @return {?}\n        */\n        function breakFunc() {\n          shouldBreak = true;\n        };\n\n        for (var i = 0; i < this._children['_results'].length; i++) {\n          if (i === this._children['_results'].length - 1) {\n            break;\n          }\n\n          if (shouldBreak) {\n            break;\n          }\n          /** @type {?} */\n\n\n          var nextChildrenWidth = childrenWidth + this._children['_results'][i + 1]._elementRef.nativeElement.clientWidth;\n          /** @type {?} */\n\n          var currentClildWidth = this._children['_results'][i]._elementRef.nativeElement.clientWidth;\n          cb(currentClildWidth, nextChildrenWidth, childrenWidth, i, breakFunc);\n          childrenWidth += currentClildWidth;\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"toChildrenLocation\",\n      value: function toChildrenLocation() {\n        /** @type {?} */\n        var to = 0;\n\n        for (var i = 0; i < this.currIndex; i++) {\n          to += this._children['_results'][i]._elementRef.nativeElement.clientWidth;\n        }\n\n        return to;\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @return {?}\n       */\n\n    }, {\n      key: \"locateDragScrollItem\",\n      value: function locateDragScrollItem(element) {\n        /** @type {?} */\n        var item = null;\n\n        for (var i = 0; i < this._children['_results'].length; i++) {\n          if (element === this._children['_results'][i]._elementRef.nativeElement) {\n            item = this._children['_results'][i];\n          }\n        }\n\n        return item;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"markElDimension\",\n      value: function markElDimension() {\n        if (this.wrapper) {\n          this.elWidth = this.wrapper.style.width;\n          this.elHeight = this.wrapper.style.height;\n        } else {\n          this.elWidth = this._elementRef.nativeElement.style.width || this._elementRef.nativeElement.offsetWidth + 'px';\n          this.elHeight = this._elementRef.nativeElement.style.height || this._elementRef.nativeElement.offsetHeight + 'px';\n        }\n        /** @type {?} */\n\n\n        var container = this.wrapper || this.parentNode;\n        /** @type {?} */\n\n        var containerWidth = container ? container.clientWidth : 0;\n\n        if (this._children['_results'].length > 1) {\n          this.indexBound = this.maximumIndex(containerWidth, this._children);\n        }\n      }\n      /**\n       * @private\n       * @param {?} containerWidth\n       * @param {?} childrenElements\n       * @return {?}\n       */\n\n    }, {\n      key: \"maximumIndex\",\n      value: function maximumIndex(containerWidth, childrenElements) {\n        /** @type {?} */\n        var count = 0;\n        /** @type {?} */\n\n        var childrenWidth = 0;\n\n        for (var i = 0; i <= childrenElements['_results'].length; i++) {\n          // last N element\n\n          /** @type {?} */\n          var dragScrollItemDirective = childrenElements['_results'][childrenElements['_results'].length - 1 - i];\n\n          if (!dragScrollItemDirective) {\n            break;\n          } else {\n            /** @type {?} */\n            var nativeElement = dragScrollItemDirective._elementRef.nativeElement;\n            /** @type {?} */\n\n            var itemWidth = nativeElement.clientWidth;\n\n            if (itemWidth === 0 && nativeElement.firstElementChild) {\n              itemWidth = dragScrollItemDirective._elementRef.nativeElement.firstElementChild.clientWidth;\n            }\n\n            childrenWidth += itemWidth;\n\n            if (childrenWidth < containerWidth) {\n              count++;\n            } else {\n              break;\n            }\n          }\n        }\n\n        return childrenElements.length - count;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"isScrollReachesRightEnd\",\n      value: function isScrollReachesRightEnd() {\n        /** @type {?} */\n        var scrollLeftPos = this._contentRef.nativeElement.scrollLeft + this._contentRef.nativeElement.offsetWidth;\n        return scrollLeftPos >= this._contentRef.nativeElement.scrollWidth;\n      }\n      /**\n       * adds a margin right style to the last child element which will resolve the issue\n       * of last item gets cutoff.\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"adjustMarginToLastChild\",\n      value: function adjustMarginToLastChild() {\n        if (this._children && this.hideScrollbar) {\n          /** @type {?} */\n          var lastItem = this._children['_results'][this._children['_results'].length - 1]._elementRef.nativeElement;\n\n          if (this.wrapper && this._children['_results'].length > 1) {\n            this._renderer.setStyle(lastItem, 'margin-right', this.scrollbarWidth);\n          } else {\n            this._renderer.setStyle(lastItem, 'margin-right', 0);\n          }\n        }\n      }\n    }]);\n\n    return DragScrollComponent;\n  }();\n\n  DragScrollComponent.ɵfac = function DragScrollComponent_Factory(t) {\n    return new (t || DragScrollComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  DragScrollComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DragScrollComponent,\n    selectors: [[\"drag-scroll\"]],\n    contentQueries: function DragScrollComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DragScrollItemDirective, 4);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._children = _t);\n      }\n    },\n    viewQuery: function DragScrollComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentRef = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function DragScrollComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"wheel\", function DragScrollComponent_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        })(\"resize\", function DragScrollComponent_resize_HostBindingHandler() {\n          return ctx.onWindowResize();\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"pointer-events\", ctx._pointerEvents);\n      }\n    },\n    inputs: {\n      scrollbarHidden: [\"scrollbar-hidden\", \"scrollbarHidden\"],\n      disabled: [\"drag-scroll-disabled\", \"disabled\"],\n      xDisabled: [\"drag-scroll-x-disabled\", \"xDisabled\"],\n      yDisabled: [\"drag-scroll-y-disabled\", \"yDisabled\"],\n      xWheelEnabled: [\"scroll-x-wheel-enabled\", \"xWheelEnabled\"],\n      dragDisabled: [\"drag-disabled\", \"dragDisabled\"],\n      snapDisabled: [\"snap-disabled\", \"snapDisabled\"],\n      snapOffset: [\"snap-offset\", \"snapOffset\"],\n      snapDuration: [\"snap-duration\", \"snapDuration\"]\n    },\n    outputs: {\n      dsInitialized: \"dsInitialized\",\n      indexChanged: \"indexChanged\",\n      reachesLeftBound: \"reachesLeftBound\",\n      reachesRightBound: \"reachesRightBound\",\n      snapAnimationFinished: \"snapAnimationFinished\",\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"drag-scroll-content\"], [\"contentRef\", \"\"]],\n    template: function DragScrollComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    styles: [\"[_nghost-%COMP%] {\\n      overflow: hidden;\\n      display: block;\\n    }\\n    .drag-scroll-content[_ngcontent-%COMP%] {\\n      height: 100%;\\n      overflow: auto;\\n      white-space: nowrap;\\n    }\"]\n  });\n  return DragScrollComponent;\n}();\n\nvar DragScrollModule = /*@__PURE__*/function () {\n  var DragScrollModule = /*#__PURE__*/_createClass(function DragScrollModule() {\n    _classCallCheck(this, DragScrollModule);\n  });\n\n  DragScrollModule.ɵfac = function DragScrollModule_Factory(t) {\n    return new (t || DragScrollModule)();\n  };\n\n  DragScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DragScrollModule\n  });\n  DragScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return DragScrollModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragScrollModule, {\n    declarations: [DragScrollComponent, DragScrollItemDirective],\n    exports: [DragScrollComponent, DragScrollItemDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragScrollComponent, DragScrollItemDirective, DragScrollModule }; //# sourceMappingURL=ngx-drag-scroll.js.map","map":null,"metadata":{},"sourceType":"module"}