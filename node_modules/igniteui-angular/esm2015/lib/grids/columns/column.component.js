import { __decorate } from "tslib";
import { Subject } from 'rxjs';
import { ChangeDetectorRef, ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Input, Output, EventEmitter, } from '@angular/core';
import { notifyChanges } from '../watch-changes';
import { WatchColumnChanges } from '../watch-changes';
import { DataType } from '../../data-operations/data-util';
import { IgxBooleanFilteringOperand, IgxNumberFilteringOperand, IgxDateFilteringOperand, IgxStringFilteringOperand } from '../../data-operations/filtering-condition';
import { DefaultSortingStrategy } from '../../data-operations/sorting-strategy';
import { DisplayDensity } from '../../core/displayDensity';
import { IgxRowDirective } from '../row.directive';
import { GridBaseAPIService } from '../api.service';
import { getNodeSizeViaRange, isConstructor } from '../../core/utils';
import { IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand, IgxCurrencySummaryOperand, IgxPercentSummaryOperand } from '../summaries/grid-summary';
import { IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCollapsibleIndicatorTemplateDirective, IgxFilterCellTemplateDirective } from './templates.directive';
import { DropPosition } from '../moving/moving.service';
const DEFAULT_DATE_FORMAT = 'mediumDate';
const DEFAULT_DIGITS_INFO = '1.0-3';
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid/grid#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
export class IgxColumnComponent {
    constructor(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets the `title` value.
         * ```typescript
         * let title = this.column.title;
         * ```
         * ```html
         * <igx-column [title] = "'Some column tooltip'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.title = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /** @hidden */
        this.onColumnChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets conditional style properties on the column header.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerStyles = null;
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column header group wrapper.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (column) => column.pinned ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [headerGroupStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.headerGroupStyles = null;
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') ? 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        this._vIndex = NaN;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._calcWidth = null;
        this._columnPipeArgs = { format: DEFAULT_DATE_FORMAT, digitsInfo: DEFAULT_DIGITS_INFO };
    }
    /**
     * Sets/gets the `field` value.
     * ```typescript
     * let columnField = this.column.field;
     * ```
     * ```html
     * <igx-column [field] = "'ID'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set field(value) {
        this._field = value;
        this.hasNestedPath = value === null || value === void 0 ? void 0 : value.includes('.');
    }
    get field() {
        return this._field;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            if (value) {
                this.grid.selectionService.selectColumnsWithNoEvent([this.field]);
            }
            else {
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            }
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * @hidden
     */
    get maxWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) / 100 * gridAvailableSize : parseFloat(this.maxWidth);
    }
    /**
     * @hidden
     */
    get maxWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.maxWidth && typeof this.maxWidth === 'string' && this.maxWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.maxWidth) : parseFloat(this.maxWidth) / gridAvailableSize * 100;
    }
    /**
     * @hidden
     */
    get minWidthPx() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) / 100 * gridAvailableSize : parseFloat(this.minWidth);
    }
    /**
     * @hidden
     */
    get minWidthPercent() {
        const gridAvailableSize = this.grid.calcWidth;
        const isPercentageWidth = this.minWidth && typeof this.minWidth === 'string' && this.minWidth.indexOf('%') !== -1;
        return isPercentageWidth ? parseFloat(this.minWidth) : parseFloat(this.minWidth) / gridAvailableSize * 100;
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                if (value) {
                    this.pin();
                }
                else {
                    this.unpin();
                }
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        if (isConstructor(classRef)) {
            this._summaries = new classRef();
        }
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     *
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * @remarks
     * Pass optional parameters for DatePipe and/or DecimalPipe to format the display value for date and numeric columns.
     * Accepts an `IColumnPipeArgs` object with any of the `format`, `timezone` and `digitsInfo` properties.
     * For more details see https://angular.io/api/common/DatePipe and https://angular.io/api/common/DecimalPipe
     * @example
     * ```typescript
     * const pipeArgs: IColumnPipeArgs = {
     *      format: 'longDate',
     *      timezone: 'UTC',
     *      digitsInfo: '1.1-2'
     * }
     * ```
     * ```html
     * <igx-column dataType="date" [pipeArgs]="pipeArgs"></igx-column>
     * <igx-column dataType="number" [pipeArgs]="pipeArgs"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pipeArgs(value) {
        this._columnPipeArgs = Object.assign(this._columnPipeArgs, value);
        this.grid.summaryService.clearSummaryCache();
        this.grid._pipeTrigger++;
        this.grid.notifyChanges();
    }
    get pipeArgs() {
        return this._columnPipeArgs;
    }
    /**
     * @hidden
     * @internal
     */
    get collapsible() {
        return false;
    }
    set collapsible(_value) { }
    /**
     * @hidden
     * @internal
     */
    get expanded() {
        return true;
    }
    set expanded(_value) { }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                case DataType.Currency:
                    this.summaries = IgxCurrencySummaryOperand;
                    break;
                case DataType.Percent:
                    this.summaries = IgxPercentSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                case DataType.Currency:
                case DataType.Percent:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (const size of columnSizes) {
            if (size && !!size.width) {
                result.push(size.width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (const target of targets) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === target.target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(target);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area.
     * Defaults to index `0` if not provided, or to the initial index in the pinned area.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        const grid = this.grid;
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        const rootPinnedCols = grid._pinnedColumns.filter((c) => c.level === 0);
        index = hasIndex ? index : rootPinnedCols.length;
        const args = { column: this, insertAtIndex: index, isPinned: false, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        grid.endEdit(false);
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._pinnedColumns.length ?
            grid._pinnedColumns[args.insertAtIndex - 1] : grid._pinnedColumns[args.insertAtIndex];
        if (grid._pinnedColumns.indexOf(this) === -1) {
            if (!grid.hasColumnGroups) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            }
            else {
                // insert based only on root collection
                rootPinnedCols.splice(args.insertAtIndex, 0, this);
                let allPinned = [];
                // re-create hierarchy
                rootPinnedCols.forEach(group => {
                    allPinned.push(group);
                    allPinned = allPinned.concat(group.allChildren);
                });
                grid._pinnedColumns = allPinned;
            }
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                const childrenCount = this.allChildren.length;
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1 + childrenCount);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        const eventArgs = { column: this, insertAtIndex: index, isPinned: true };
        this.grid.columnPinned.emit(eventArgs);
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area.
     * Defaults to index `0` if not provided, or to the initial index in the unpinned area.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     *
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        const grid = this.grid;
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index > grid._unpinnedColumns.length)) {
            return false;
        }
        // estimate the exact index at which column will be inserted
        // takes into account initial unpinned index of the column
        if (!hasIndex) {
            const indices = grid.unpinnedColumns.map(col => col.index);
            indices.push(this.index);
            indices.sort((a, b) => a - b);
            index = indices.indexOf(this.index);
        }
        const args = { column: this, insertAtIndex: index, isPinned: true, cancel: false };
        this.grid.onColumnPinning.emit(args);
        if (args.cancel) {
            return;
        }
        this.grid.endEdit(false);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        // it is possible that index is the last position, so will need to find target column by [index-1]
        const targetColumn = args.insertAtIndex === grid._unpinnedColumns.length ?
            grid._unpinnedColumns[args.insertAtIndex - 1] : grid._unpinnedColumns[args.insertAtIndex];
        if (!hasIndex) {
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid.moveColumn(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        this.grid.columnPinned.emit({ column: this, insertAtIndex: index, isPinned: false });
        return true;
    }
    /**
     * Moves a column to the specified visible index.
     * If passed index is invalid, or if column would receive a different visible index after moving, moving is not performed.
     * If passed index would move the column to a different column group. moving is not performed.
     *
     * @example
     * ```typescript
     * column.move(index);
     * ```
     * @memberof IgxColumnComponent
     */
    move(index) {
        let target;
        const grid = this.grid;
        let columns = grid.columnList.filter(c => c.visibleIndex > -1);
        // grid last visible index
        const li = columns.map(c => c.visibleIndex).reduce((a, b) => Math.max(a, b));
        const parent = this.parent;
        const isPreceding = this.visibleIndex < index;
        if (index === this.visibleIndex || index < 0 || index > li) {
            return;
        }
        if (parent) {
            columns = columns.filter(c => c.level >= this.level && c !== this && c.parent !== this &&
                c.topLevelParent === this.topLevelParent);
        }
        /* eslint-disable max-len */
        // If isPreceding, find a target such that when the current column is placed after it, current colummn will receive a visibleIndex === index. This takes into account visible children of the columns.
        // If !isPreceding, finds a column of the same level and visible index that equals the passed index agument (c.visibleIndex === index). No need to consider the children here.
        /* eslint-enable max-len */
        if (isPreceding) {
            columns = columns.filter(c => c.visibleIndex > this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex + c.calcChildren() - this.calcChildren() === index);
        }
        else {
            columns = columns.filter(c => c.visibleIndex < this.visibleIndex);
            target = columns.find(c => c.level === this.level && c.visibleIndex === index);
        }
        if (!target || (target.pinned && this.disablePinning)) {
            return;
        }
        const pos = isPreceding ? DropPosition.AfterDropTarget : DropPosition.BeforeDropTarget;
        grid.moveColumn(this, target, pos);
    }
    /**
     * No children for the column, so will returns 1 or 0, if the column is hidden.
     *
     * @hidden
     */
    calcChildren() {
        const children = this.hidden ? 0 : 1;
        return children;
    }
    /**
     * Toggles column vibisility and emits the respective event.
     *
     * @hidden
     */
    toggleVisibility(value) {
        const newValue = value !== null && value !== void 0 ? value : !this.hidden;
        const eventArgs = { column: this, newValue, cancel: false };
        this.grid.columnVisibilityChanging.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        this.hidden = newValue;
        this.grid.onColumnVisibilityChanged.emit({ column: this, newValue });
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     *
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     *
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     *
     * @memberof IgxColumnComponent
     * @param byHeader Set if column should be autized based only on the header content
     */
    autosize(byHeader = false) {
        if (!this.columnGroup) {
            const size = this.getAutoSize(byHeader);
            this.width = size;
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getAutoSize(byHeader = false) {
        const size = !byHeader ? this.getLargestCellWidth() :
            (Object.values(this.getHeaderCellWidths()).reduce((a, b) => a + b) + 'px');
        const gridAvailableSize = this.grid.calcWidth;
        let newWidth;
        const isPercentageWidth = this.width && typeof this.width === 'string' && this.width.indexOf('%') !== -1;
        if (isPercentageWidth) {
            const percentageSize = parseFloat(size) / gridAvailableSize * 100;
            newWidth = percentageSize + '%';
        }
        else {
            newWidth = size;
        }
        return newWidth;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the width and padding of a header cell.
     */
    getHeaderCellWidths() {
        const range = this.grid.document.createRange();
        let headerWidth;
        if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
            headerWidth = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                .map((child) => getNodeSizeViaRange(range, child)));
        }
        else {
            headerWidth = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
        }
        if (this.sortable || this.filterable) {
            headerWidth += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
        }
        const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
        const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
            parseFloat(headerStyle.borderRightWidth);
        // Take into consideration the header group element, since column pinning applies borders to it if its not a columnGroup.
        const headerGroupStyle = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement);
        const borderSize = !this.parent ? parseFloat(headerGroupStyle.borderRightWidth) + parseFloat(headerGroupStyle.borderLeftWidth) : 0;
        return { width: Math.ceil(headerWidth), padding: Math.ceil(headerPadding + borderSize) };
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this.cells.length > 0) {
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderLeftWidth) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            const headerCellWidths = this.getHeaderCellWidths();
            largest.set(headerCellWidths.width, headerCellWidths.padding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseFloat(colWidth) / 100 * grid.calcWidth;
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseFloat(this._calcWidth);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
}
IgxColumnComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            },] }
];
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef }
];
IgxColumnComponent.propDecorators = {
    field: [{ type: Input }],
    header: [{ type: Input }],
    title: [{ type: Input }],
    sortable: [{ type: Input }],
    selectable: [{ type: Input }],
    groupable: [{ type: Input }],
    editable: [{ type: Input }],
    filterable: [{ type: Input }],
    resizable: [{ type: Input }],
    hasSummary: [{ type: Input }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }],
    expandedChange: [{ type: Output }],
    collapsibleChange: [{ type: Output }],
    visibleWhenCollapsedChange: [{ type: Output }],
    onColumnChange: [{ type: Output }],
    disableHiding: [{ type: Input }],
    disablePinning: [{ type: Input }],
    movable: [{ type: Input }],
    width: [{ type: Input }],
    maxWidth: [{ type: Input }],
    headerClasses: [{ type: Input }],
    headerStyles: [{ type: Input }],
    headerGroupClasses: [{ type: Input }],
    headerGroupStyles: [{ type: Input }],
    cellClasses: [{ type: Input }],
    cellStyles: [{ type: Input }],
    formatter: [{ type: Input }],
    filteringIgnoreCase: [{ type: Input }],
    sortingIgnoreCase: [{ type: Input }],
    searchable: [{ type: Input }],
    dataType: [{ type: Input }],
    collapsibleIndicatorTemplate: [{ type: Input }],
    rowEnd: [{ type: Input }],
    colEnd: [{ type: Input }],
    rowStart: [{ type: Input }],
    colStart: [{ type: Input }],
    additionalTemplateContext: [{ type: Input }],
    widthChange: [{ type: Output }],
    pinnedChange: [{ type: Output }],
    filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }],
    cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
    headTemplate: [{ type: ContentChildren, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false },] }],
    editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
    collapseIndicatorTemplate: [{ type: ContentChild, args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false },] }],
    minWidth: [{ type: Input }],
    pinned: [{ type: Input }],
    summaries: [{ type: Input }],
    filters: [{ type: Input }],
    sortStrategy: [{ type: Input }],
    groupingComparer: [{ type: Input }],
    bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
    headerTemplate: [{ type: Input }],
    inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
    filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
    visibleWhenCollapsed: [{ type: Input }],
    pipeArgs: [{ type: Input }]
};
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "title", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerGroupStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    WatchColumnChanges()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges()
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    notifyChanges(true)
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9jb2x1bW5zL2NvbHVtbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUVILGlCQUFpQixFQUNqQix1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBQ2YsS0FBSyxFQUdMLE1BQU0sRUFDTixZQUFZLEdBRWYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRCxPQUFPLEVBRUgsMEJBQTBCLEVBQzFCLHlCQUF5QixFQUN6Qix1QkFBdUIsRUFDdkIseUJBQXlCLEVBQzVCLE1BQU0sMkNBQTJDLENBQUM7QUFDbkQsT0FBTyxFQUFvQixzQkFBc0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUczRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLcEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSx1QkFBdUIsRUFBRSxxQkFBcUIsRUFDdEUseUJBQXlCLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRixPQUFPLEVBQ0gsd0JB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QUhDLGFBQWEsRUFBRTtJQUNmLGtCQUFrQixFQUFFOzREQUlwQjtBQW1MRDtJQUZDLGFBQWEsQ0FBQyxJQUFJLENBQUM7OERBUW5CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIElucHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBPdXRwdXQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIE9uRGVzdHJveSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBub3RpZnlDaGFuZ2VzIH0gZnJvbSAnLi4vd2F0Y2gtY2hhbmdlcyc7XG5pbXBvcnQgeyBXYXRjaENvbHVtbkNoYW5nZXMgfSBmcm9tICcuLi93YXRjaC1jaGFuZ2VzJztcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQge1xuICAgIElneEZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4Qm9vbGVhbkZpbHRlcmluZ09wZXJhbmQsXG4gICAgSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hEYXRlRmlsdGVyaW5nT3BlcmFuZCxcbiAgICBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kXG59IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctY29uZGl0aW9uJztcbmltcG9ydCB7IElTb3J0aW5nU3RyYXRlZ3ksIERlZmF1bHRTb3J0aW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBEaXNwbGF5RGVuc2l0eSB9IGZyb20gJy4uLy4uL2NvcmUvZGlzcGxheURlbnNpdHknO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VEaXJlY3RpdmUgfSBmcm9tICcuLi9ncmlkLWJhc2UuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Um93RGlyZWN0aXZlIH0gZnJvbSAnLi4vcm93LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWV4cHJlc3Npb25zLXRyZWUnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRGaWx0ZXJpbmdDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyaW5nL2Jhc2UvZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi4vaGVhZGVycy9ncmlkLWhlYWRlci1ncm91cC5jb21wb25lbnQnO1xuaW1wb3J0IHsgZ2V0Tm9kZVNpemVWaWFSYW5nZSwgaXNDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4U3VtbWFyeU9wZXJhbmQsIElneE51bWJlclN1bW1hcnlPcGVyYW5kLCBJZ3hEYXRlU3VtbWFyeU9wZXJhbmQsXG4gICAgSWd4Q3VycmVuY3lTdW1tYXJ5T3BlcmFuZCwgSWd4UGVyY2VudFN1bW1hcnlPcGVyYW5kIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtc3VtbWFyeSc7XG5pbXBvcnQge1xuICAgIElneENlbGxUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2VsbEVkaXRvclRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlXG59IGZyb20gJy4vdGVtcGxhdGVzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNUkxSZXNpemVDb2x1bW5JbmZvLCBNUkxDb2x1bW5TaXplSW5mbywgSUNvbHVtblBpcGVBcmdzIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IERyb3BQb3NpdGlvbiB9IGZyb20gJy4uL21vdmluZy9tb3Zpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudCB9IGZyb20gJy4vY29sdW1uLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJQ29sdW1uVmlzaWJpbGl0eUNoYW5naW5nRXZlbnRBcmdzLCBJUGluQ29sdW1uQ2FuY2VsbGFibGVFdmVudEFyZ3MsIElQaW5Db2x1bW5FdmVudEFyZ3MgfSBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcblxuY29uc3QgREVGQVVMVF9EQVRFX0ZPUk1BVCA9ICdtZWRpdW1EYXRlJztcbmNvbnN0IERFRkFVTFRfRElHSVRTX0lORk8gPSAnMS4wLTMnO1xuXG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIENvbHVtbioqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkL2dyaWQjY29sdW1ucy1jb25maWd1cmF0aW9uKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgQ29sdW1uIGlzIHVzZWQgd2l0aGluIGFuIGBpZ3gtZ3JpZGAgZWxlbWVudCB0byBkZWZpbmUgd2hhdCBkYXRhIHRoZSBjb2x1bW4gd2lsbCBzaG93LiBGZWF0dXJlcyBzdWNoIGFzIHNvcnRpbmcsXG4gKiBmaWx0ZXJpbmcgJiBlZGl0aW5nIGFyZSBlbmFibGVkIGF0IHRoZSBjb2x1bW4gbGV2ZWwuICBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHRlbXBsYXRlIGNvbnRhaW5pbmcgY3VzdG9tIGNvbnRlbnQgaW5zaWRlXG4gKiB0aGUgY29sdW1uIHVzaW5nIGBuZy10ZW1wbGF0ZWAgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBhbGwgY2VsbHMgd2l0aGluIHRoZSBjb2x1bW4uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiAnaWd4LWNvbHVtbicsXG4gICAgdGVtcGxhdGU6IGBgXG59KVxuZXhwb3J0IGNsYXNzIElneENvbHVtbkNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgZmllbGRgIHZhbHVlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmllbGQgPSB0aGlzLmNvbHVtbi5maWVsZDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2ZpZWxkXSA9IFwiJ0lEJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBmaWVsZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzTmVzdGVkUGF0aCA9IHZhbHVlPy5pbmNsdWRlcygnLicpO1xuICAgIH1cbiAgICBnZXQgZmllbGQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgYGhlYWRlcmAgdmFsdWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5IZWFkZXIgPSB0aGlzLmNvbHVtbi5oZWFkZXI7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtoZWFkZXJdID0gXCInSUQnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXIgPSAnJztcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGB0aXRsZWAgdmFsdWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCB0aXRsZSA9IHRoaXMuY29sdW1uLnRpdGxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbdGl0bGVdID0gXCInU29tZSBjb2x1bW4gdG9vbHRpcCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpdGxlID0gJyc7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NvcnRhYmxlID0gdGhpcy5jb2x1bW4uc29ydGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtzb3J0YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc29ydGFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBjb2x1bW4gaXMgc2VsZWN0YWJsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtblNlbGVjdGFibGUgPSB0aGlzLmNvbHVtbi5zZWxlY3RhYmxlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHNlbGVjdGFibGUoKTogYm9vbGVhbiAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoZSBjb2x1bW4gaXMgc2VsZWN0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3NlbGVjdGFibGVdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0YWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBncm91cGFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNHcm91cGFibGUgPSB0aGlzLmNvbHVtbi5ncm91cGFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtncm91cGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKHRydWUpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBncm91cGFibGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0VkaXRhYmxlID0gdGhpcy5jb2x1bW4uZWRpdGFibGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBnZXQgZWRpdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwcmltYXJ5IGtleSB3aGVuIGdyaWQgaGFzIHRyYW5zYWN0aW9ucyAoaW5jbC4gcm93IGVkaXQpXG4gICAgICAgIC8vIHNob3VsZCBub3QgYmUgYWxsb3dlZCwgYXMgdGhhdCBjYW4gY29ycnVwdCB0cmFuc2FjdGlvbiBzdGF0ZS5cbiAgICAgICAgY29uc3Qgcm93RWRpdGFibGUgPSB0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLnJvd0VkaXRhYmxlO1xuICAgICAgICBjb25zdCBoYXNUcmFuc2FjdGlvbnMgPSB0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLnRyYW5zYWN0aW9ucy5lbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeUNvbHVtbiAmJiAocm93RWRpdGFibGUgfHwgaGFzVHJhbnNhY3Rpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2VkaXRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByb3dFZGl0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBlZGl0YWJsZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uZWRpdGFibGUgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZWRpdGFibGVdID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBlZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGZpbHRlcmFibGUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0ZpbHRlcmFibGUgPSB0aGlzLmNvbHVtbi5maWx0ZXJhYmxlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBmaWx0ZXJhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIHJlc2l6YWJsZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1Jlc2l6YWJsZSA9IHRoaXMuY29sdW1uLnJlc2l6YWJsZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3Jlc2l6YWJsZV0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcmVzaXphYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VtbWFyeSBmb3IgdGhlIGNvbHVtbiBpcyBlbmFibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGFzU3VtbWFyeSA9IHRoaXMuY29sdW1uLmhhc1N1bW1hcnk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBoYXNTdW1tYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzU3VtbWFyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VtbWFyeSBmb3IgdGhlIGNvbHVtbiBpcyBlbmFibGVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hhc1N1bW1hcnldID0gXCJ0cnVlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBoYXNTdW1tYXJ5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hhc1N1bW1hcnkgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UucmVzZXRTdW1tYXJ5SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgaGlkZGVuLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNIaWRkZW4gPSB0aGlzLmNvbHVtbi5oaWRkZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBoaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRkZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBoaWRkZW4gcHJvcGVydHkuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGlkZGVuXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbKGhpZGRlbildID0gXCJtb2RlbC5pc0hpZGRlblwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWRkZW4gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuQ2hhbmdlLmVtaXQodGhpcy5faGlkZGVuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkxheW91dENoaWxkICYmIHRoaXMucGFyZW50LmhpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmVuZEVkaXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5zdW1tYXJ5U2VydmljZS5yZXNldFN1bW1hcnlIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS5yZWZyZXNoRXhwcmVzc2lvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZmlsdGVyaW5nU2VydmljZS5oaWRlRmlsdGVyaW5nUm93T25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBjb2x1bW4gaXMgc2VsZWN0ZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NlbGVjdGVkID0gdGhpcy5jb2x1bW4uc2VsZWN0ZWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvblNlcnZpY2UuaXNDb2x1bW5TZWxlY3RlZCh0aGlzLmZpZWxkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QvZGVzZWxlY3QgYSBjb2x1bW4uXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgZmFsc2VgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUgJiYgdmFsdWUgIT09IHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdENvbHVtbnNXaXRoTm9FdmVudChbdGhpcy5maWVsZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdENvbHVtbnNXaXRoTm9FdmVudChbdGhpcy5maWVsZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgaGlkZGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjb2xsYXBzaWJsZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyB2aXNpYmxlV2hlbkNvbGxhcHNlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ29sdW1uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBoaWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc0hpZGluZ0Rpc2FibGVkID0gIHRoaXMuY29sdW1uLmRpc2FibGVIaWRpbmc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZUhpZGluZyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcGlubmluZyBpcyBkaXNhYmxlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzUGlubmluZ0Rpc2FibGVkID0gIHRoaXMuY29sdW1uLmRpc2FibGVQaW5uaW5nO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVQaW5uaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBtb3ZhYmxlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlzTW92YWJsZSA9IHRoaXMuY29sdW1uLm1vdmFibGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttb3ZhYmxlXSA9IFwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbW92YWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbldpZHRoID0gdGhpcy5jb2x1bW4ud2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGhTZXRCeVVzZXIgPyB0aGlzLl93aWR0aCA6IHRoaXMuZGVmYXVsdFdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3dpZHRoXSA9IFwiJzI1JSdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyh3aWR0aCldPVwibW9kZWwuY29sdW1uc1swXS53aWR0aFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHdpZHRoKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jYWxjUGl4ZWxXaWR0aCA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMud2lkdGhTZXRCeVVzZXIgPSB0cnVlO1xuICAgICAgICAgICAgLy8gd2lkdGggY291bGQgYmUgcGFzc2VkIGFzIG51bWJlciBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gaG9zdCBiaW5kaW5ncyBhcmUgbm90IHB4IGFmZml4ZWQgc28gd2UgbmVlZCB0byBlbnN1cmUgd2UgYWZmaXggc2ltcGxlIG51bWJlciBzdHJpbmdzXG4gICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicgfHwgdmFsdWUubWF0Y2goL15bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUNhbGNXaWR0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aWR0aENoYW5nZS5lbWl0KHRoaXMuX3dpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgbWF4aW11bSBgd2lkdGhgIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5NYXhXaWR0aCA9IHRoaXMuY29sdW1uLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbbWF4V2lkdGhdID0gXCInMTUwcHgnXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG1heFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNsYXNzIHNlbGVjdG9yIG9mIHRoZSBjb2x1bW4gaGVhZGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSGVhZGVyQ2xhc3MgPSB0aGlzLmNvbHVtbi5oZWFkZXJDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyQ2xhc3Nlc10gPSBcIidjb2x1bW4taGVhZGVyJ1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGVhZGVyQ2xhc3NlcyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb25kaXRpb25hbCBzdHlsZSBwcm9wZXJ0aWVzIG9uIHRoZSBjb2x1bW4gaGVhZGVyLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHN0eWxlcyA9IHtcbiAgICAgKiAgYmFja2dyb3VuZDogJ3JveWFsYmx1ZScsXG4gICAgICogIGNvbG9yOiAoY29sdW1uKSA9PiBjb2x1bW4ucGlubmVkID8gJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlclN0eWxlc109XCJzdHlsZXNcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgIEBJbnB1dCgpXG4gICAgIHB1YmxpYyBoZWFkZXJTdHlsZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGdyb3VwIGhlYWRlci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkhlYWRlckNsYXNzID0gdGhpcy5jb2x1bW4uaGVhZGVyR3JvdXBDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbaGVhZGVyR3JvdXBDbGFzc2VzXSA9IFwiJ2NvbHVtbi1ncm91cC1oZWFkZXInXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoZWFkZXJHcm91cENsYXNzZXMgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29uZGl0aW9uYWwgc3R5bGUgcHJvcGVydGllcyBvbiB0aGUgY29sdW1uIGhlYWRlciBncm91cCB3cmFwcGVyLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHN0eWxlcyA9IHtcbiAgICAgKiAgYmFja2dyb3VuZDogJ3JveWFsYmx1ZScsXG4gICAgICogIGNvbG9yOiAoY29sdW1uKSA9PiBjb2x1bW4ucGlubmVkID8gJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2hlYWRlckdyb3VwU3R5bGVzXT1cInN0eWxlc1wiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICAgQElucHV0KClcbiAgICAgcHVibGljIGhlYWRlckdyb3VwU3R5bGVzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjb25kaXRpb25hbCBjbGFzcyBzZWxlY3RvciBvZiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIEFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwsIGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzLFxuICAgICAqIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5hbWUgb2YgdGhlIENTUyBjbGFzcywgd2hpbGUgdGhlXG4gICAgICogdmFsdWUgaXMgZWl0aGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbixcbiAgICAgKiBvciBib29sZWFuLCBsaWtlIHNvOlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjYWxsYmFjayA9IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHsgcmV0dXJuIHJvd0RhdGFbY29sdW1uS2V5XSA+IDY7IH1cbiAgICAgKiBjZWxsQ2xhc3NlcyA9IHsgJ2NsYXNzTmFtZScgOiB0aGlzLmNhbGxiYWNrIH07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcImNlbGxDbGFzc2VzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDxpZ3gtY29sdW1uIFtjZWxsQ2xhc3Nlc10gPSBcInsnY2xhc3MxJyA6IHRydWUgfVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2VsbENsYXNzZXM6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29uZGl0aW9uYWwgc3R5bGUgcHJvcGVydGllcyBvbiB0aGUgY29sdW1uIGNlbGxzLlxuICAgICAqIFNpbWlsYXIgdG8gYG5nU3R5bGVgIGl0IGFjY2VwdHMgYW4gb2JqZWN0IGxpdGVyYWwgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQXMgd2l0aCBgY2VsbENsYXNzZXNgIGl0IGFjY2VwdHMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogc3R5bGVzID0ge1xuICAgICAqICBiYWNrZ3JvdW5kOiAncm95YWxibHVlJyxcbiAgICAgKiAgY29sb3I6IChyb3dEYXRhLCBjb2x1bW5LZXksIGNlbGxWYWx1ZSwgcm93SW5kZXgpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ0ltcG9ydGFudCcpID8gJ3JlZCc6ICdpbmhlcml0J1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2NlbGxTdHlsZXNdPVwic3R5bGVzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGNlbGxTdHlsZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZGlzcGxheSBmb3JtYXQgdG8gY2VsbCB2YWx1ZXMgaW4gdGhlIGNvbHVtbi4gRG9lcyBub3QgbW9kaWZ5IHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrXG4gICAgICogTm90ZTogQXMgdGhlIGZvcm1hdHRlciBpcyB1c2VkIGluIHBsYWNlcyBsaWtlIHRoZSBFeGNlbCBzdHlsZSBmaWx0ZXJpbmcgZGlhbG9nLCBpbiBjZXJ0YWluXG4gICAgICogc2NlbmFyaW9zIChyZW1vdGUgZmlsdGVyaW5nIGZvciBleGFtcGxlKSwgdGhlIHJvdyBkYXRhIGFyZ3VtZW50IGNhbiBiZSBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqXG4gICAgICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGNvbHVtbiBuYW1lIGlzIFNhbGFyeSwgYW5kIHRoZW4gcHJvdmlkZSBhIG1ldGhvZCBhcyB0aGUgY29sdW1uIGZvcm1hdHRlclxuICAgICAqIHRvIGZvcm1hdCB0aGUgdmFsdWUgaW50byBhIGN1cnJlbmN5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQ29sdW1uSW5pdChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAqICAgaWYgKGNvbHVtbi5maWVsZCA9PSBcIlNhbGFyeVwiKSB7XG4gICAgICogICAgIGNvbHVtbi5mb3JtYXR0ZXIgPSAoc2FsYXJ5ID0+IHRoaXMuZm9ybWF0KHNhbGFyeSkpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZvcm1hdCh2YWx1ZTogbnVtYmVyKSA6IHN0cmluZyB7XG4gICAgICogICByZXR1cm4gZm9ybWF0Q3VycmVuY3kodmFsdWUsIFwiZW4tdXNcIiwgXCIkXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbHVtbiA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5CeU5hbWUoJ0FkZHJlc3MnKTtcbiAgICAgKiBjb25zdCBhZGRyZXNzRm9ybWF0dGVyID0gKGFkZHJlc3M6IHN0cmluZywgcm93RGF0YTogYW55KSA9PiBkYXRhLnByaXZhY3lFbmFibGVkID8gJ3Vua25vd24nIDogYWRkcmVzcztcbiAgICAgKiBjb2x1bW4uZm9ybWF0dGVyID0gYWRkcmVzc0Zvcm1hdHRlcjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZm9ybWF0dGVyOiAodmFsdWU6IGFueSwgcm93RGF0YT86IGFueSkgPT4gYW55O1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0aGlzLmNvbHVtbi5maWx0ZXJpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbZmlsdGVyaW5nSWdub3JlQ2FzZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGZpbHRlcmluZ0lnbm9yZUNhc2UgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gc29ydGluZyBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzb3J0aW5nSWdub3JlQ2FzZSA9IHRoaXMuY29sdW1uLnNvcnRpbmdJZ25vcmVDYXNlO1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbc29ydGluZ0lnbm9yZUNhc2VdID0gXCJmYWxzZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzb3J0aW5nSWdub3JlQ2FzZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyBgc2VhcmNoYWJsZWAuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBpc1NlYXJjaGFibGUgPSAgdGhpcy5jb2x1bW4uc2VhcmNoYWJsZSc7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWNvbHVtbiBbc2VhcmNoYWJsZV0gPSBcImZhbHNlXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZWFyY2hhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgY29sdW1uIHZhbHVlcy5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBzdHJpbmdgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRGF0YVR5cGUgPSB0aGlzLmNvbHVtbi5kYXRhVHlwZTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW2RhdGFUeXBlXSA9IFwiJ251bWJlcidcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGF0YVR5cGU6IERhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogUm93IGluZGV4IHdoZXJlIHRoZSBjdXJyZW50IGZpZWxkIHNob3VsZCBlbmQuXG4gICAgICogVGhlIGFtb3VudCBvZiByb3dzIGJldHdlZW4gcm93U3RhcnQgYW5kIHJvd0VuZCB3aWxsIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHNwYW5uaW5nIHJvd3MgdG8gdGhhdCBmaWVsZFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogICA8aWd4LWNvbHVtbiBbcm93RW5kXT1cIjJcIiBbcm93U3RhcnRdPVwiMVwiIFtjb2xTdGFydF09XCIxXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWNvbHVtbi1sYXlvdXQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm93RW5kOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb2x1bW4gaW5kZXggd2hlcmUgdGhlIGN1cnJlbnQgZmllbGQgc2hvdWxkIGVuZC5cbiAgICAgKiBUaGUgYW1vdW50IG9mIGNvbHVtbnMgYmV0d2VlbiBjb2xTdGFydCBhbmQgY29sRW5kIHdpbGwgZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygc3Bhbm5pbmcgY29sdW1ucyB0byB0aGF0IGZpZWxkXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtjb2xFbmRdPVwiM1wiIFtyb3dTdGFydF09XCIxXCIgW2NvbFN0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb2xFbmQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFJvdyBpbmRleCBmcm9tIHdoaWNoIHRoZSBmaWVsZCBpcyBzdGFydGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqICAgPGlneC1jb2x1bW4gW3Jvd1N0YXJ0XT1cIjFcIiBbY29sU3RhcnRdPVwiMVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tbGF5b3V0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHJvd1N0YXJ0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb2x1bW4gaW5kZXggZnJvbSB3aGljaCB0aGUgZmllbGQgaXMgc3RhcnRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiAgIDxpZ3gtY29sdW1uIFtjb2xTdGFydF09XCIxXCIgW3Jvd1N0YXJ0XT1cIjFcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtY29sdW1uLWxheW91dD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKSBjb2xTdGFydDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIGN1c3RvbSBwcm9wZXJ0aWVzIHByb3ZpZGVkIGluIGFkZGl0aW9uYWwgdGVtcGxhdGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNvbHVtbiBbYWRkaXRpb25hbFRlbXBsYXRlQ29udGV4dF09XCJjb250ZXh0T2JqZWN0XCI+XG4gICAgICogICA8bmctdGVtcGxhdGUgaWd4Q2VsbCBsZXQtY2VsbD1cImNlbGxcIiBsZXQtcHJvcHM9XCJhZGRpdGlvbmFsVGVtcGxhdGVDb250ZXh0XCI+XG4gICAgICogICAgICB7eyBwcm9wcyB9fVxuICAgICAqICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiA8L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYWRkaXRpb25hbFRlbXBsYXRlQ29udGV4dDogYW55O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyB3aWR0aENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBwaW5uZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4RmlsdGVyQ2VsbFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyBmaWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmU6IElneEZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDZWxsVGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlIH0pXG4gICAgcHJvdGVjdGVkIGNlbGxUZW1wbGF0ZTogSWd4Q2VsbFRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneENlbGxIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIGRlc2NlbmRhbnRzOiBmYWxzZSB9KVxuICAgIHByb3RlY3RlZCBoZWFkVGVtcGxhdGU6IFF1ZXJ5TGlzdDxJZ3hDZWxsSGVhZGVyVGVtcGxhdGVEaXJlY3RpdmU+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hDZWxsRWRpdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgZWRpdG9yVGVtcGxhdGU6IElneENlbGxFZGl0b3JUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hDb2xsYXBzaWJsZUluZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwcm90ZWN0ZWQgY29sbGFwc2VJbmRpY2F0b3JUZW1wbGF0ZTogIElneENvbGxhcHNpYmxlSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBjYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FsY1dpZHRoKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbGNQaXhlbFdpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhXaWR0aFB4KCkge1xuICAgICAgICBjb25zdCBncmlkQXZhaWxhYmxlU2l6ZSA9IHRoaXMuZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy5tYXhXaWR0aCAmJiB0eXBlb2YgdGhpcy5tYXhXaWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy5tYXhXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlV2lkdGggPyAgcGFyc2VGbG9hdCh0aGlzLm1heFdpZHRoKSAvIDEwMCAqIGdyaWRBdmFpbGFibGVTaXplIDogcGFyc2VGbG9hdCh0aGlzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhXaWR0aFBlcmNlbnQoKSB7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLm1heFdpZHRoICYmIHR5cGVvZiB0aGlzLm1heFdpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLm1heFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2VXaWR0aCA/ICBwYXJzZUZsb2F0KHRoaXMubWF4V2lkdGgpIDogcGFyc2VGbG9hdCh0aGlzLm1heFdpZHRoKSAvIGdyaWRBdmFpbGFibGVTaXplICogMTAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbldpZHRoUHgoKSB7XG4gICAgICAgIGNvbnN0IGdyaWRBdmFpbGFibGVTaXplID0gdGhpcy5ncmlkLmNhbGNXaWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSB0aGlzLm1pbldpZHRoICYmIHR5cGVvZiB0aGlzLm1pbldpZHRoID09PSAnc3RyaW5nJyAmJiB0aGlzLm1pbldpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2VXaWR0aCA/ICBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpIC8gMTAwICogZ3JpZEF2YWlsYWJsZVNpemUgOiBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbldpZHRoUGVyY2VudCgpIHtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBjb25zdCBpc1BlcmNlbnRhZ2VXaWR0aCA9IHRoaXMubWluV2lkdGggJiYgdHlwZW9mIHRoaXMubWluV2lkdGggPT09ICdzdHJpbmcnICYmIHRoaXMubWluV2lkdGguaW5kZXhPZignJScpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZVdpZHRoID8gIHBhcnNlRmxvYXQodGhpcy5taW5XaWR0aCkgOiBwYXJzZUZsb2F0KHRoaXMubWluV2lkdGgpIC8gZ3JpZEF2YWlsYWJsZVNpemUgKiAxMDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIG1pbmltdW0gYHdpZHRoYCBvZiB0aGUgY29sdW1uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYDg4YDtcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbk1pbldpZHRoID0gdGhpcy5jb2x1bW4ubWluV2lkdGg7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY29sdW1uIFttaW5XaWR0aF0gPSBcIicxMDBweCdcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtaW5XaWR0aCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG1pblZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1pblZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0TWluV2lkdGggPSB2YWx1ZTtcblxuICAgIH1cbiAgICBwdWJsaWMgZ2V0IG1pbldpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fZGVmYXVsdE1pbldpZHRoID8gdGhpcy5kZWZhdWx0TWluV2lkdGggOiB0aGlzLl9kZWZhdWx0TWluV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGluZGV4LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uSW5kZXggPSB0aGlzLmNvbHVtbi5pbmRleDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuY29sdW1ucy5pbmRleE9mKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciB0aGUgY29sdW1uIGlzIGBwaW5uZWRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaXNQaW5uZWQgPSB0aGlzLmNvbHVtbi5waW5uZWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHBpbm5lZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbm5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBjb2x1bW4gaXMgcGlubmVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gW3Bpbm5lZF0gPSBcInRydWVcIj48L2lneC1jb2x1bW4+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gWyhwaW5uZWQpXSA9IFwibW9kZWwuY29sdW1uc1swXS5pc1Bpbm5lZFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHBpbm5lZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fcGlubmVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCAmJiB0aGlzLndpZHRoICYmICFpc05hTihwYXJzZUludCh0aGlzLndpZHRoLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGluKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnBpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBObyBncmlkL3dpZHRoIGF2YWlsYWJsZSBhdCBpbml0aWFsaXphdGlvbi4gYGluaXRQaW5uaW5nYCBpbiB0aGUgZ3JpZFxuICAgICAgICAgICAgICAgd2lsbCByZS1pbml0IHRoZSBncm91cCAoaWYgcHJlc2VudClcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9waW5uZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGlubmVkQ2hhbmdlLmVtaXQodGhpcy5fcGlubmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBgc3VtbWFyaWVzYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtblN1bW1hcmllcyA9IHRoaXMuY29sdW1uLnN1bW1hcmllcztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcyh0cnVlKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzdW1tYXJpZXMoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcmllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sdW1uIGBzdW1tYXJpZXNgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5zdW1tYXJpZXMgPSBJZ3hOdW1iZXJTdW1tYXJ5T3BlcmFuZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHN1bW1hcmllcyhjbGFzc1JlZjogYW55KSB7XG4gICAgICAgIGlmIChpc0NvbnN0cnVjdG9yKGNsYXNzUmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fc3VtbWFyaWVzID0gbmV3IGNsYXNzUmVmKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UucmVtb3ZlU3VtbWFyaWVzQ2FjaGVQZXJDb2x1bW4odGhpcy5maWVsZCk7XG4gICAgICAgICAgICAodGhpcy5ncmlkIGFzIGFueSkuX3N1bW1hcnlQaXBlVHJpZ2dlcisrO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnN1bW1hcnlTZXJ2aWNlLnJlc2V0U3VtbWFyeUhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5GaWx0ZXJzID0gdGhpcy5jb2x1bW4uZmlsdGVycydcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZmlsdGVycygpOiBJZ3hGaWx0ZXJpbmdPcGVyYW5kIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgZmlsdGVyc2AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlcnMgPSBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpLlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZmlsdGVycyhpbnN0YW5jZTogSWd4RmlsdGVyaW5nT3BlcmFuZCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJzID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBgc29ydFN0cmF0ZWd5YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHNvcnRTdHJhdGVneSA9IHRoaXMuY29sdW1uLnNvcnRTdHJhdGVneVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzb3J0U3RyYXRlZ3koKTogSVNvcnRpbmdTdHJhdGVneSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0U3RyYXRlZ3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbHVtbiBgc29ydFN0cmF0ZWd5YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uc29ydFN0cmF0ZWd5ID0gbmV3IEN1c3RvbVNvcnRpbmdTdHJhdGVneSgpLlxuICAgICAqIGNsYXNzIEN1c3RvbVNvcnRpbmdTdHJhdGVneSBleHRlbmRzIFNvcnRpbmdTdHJhdGVneSB7Li4ufVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc29ydFN0cmF0ZWd5KGNsYXNzUmVmOiBJU29ydGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRTdHJhdGVneSA9IGNsYXNzUmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHZhbHVlcyBmb3IgZ3JvdXBpbmcuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cGluZ0NvbXBhcmVyID0gdGhpcy5jb2x1bW4uZ3JvdXBpbmdDb21wYXJlcidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZ3JvdXBpbmdDb21wYXJlcigpOiAoYTogYW55LCBiOiBhbnkpID0+IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZ0NvbXBhcmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGNvbXBhcmUgdmFsdWVzIGZvciBncm91cGluZy5cbiAgICAgKiBTdWJzZXF1ZW50IHZhbHVlcyBpbiB0aGUgc29ydGVkIGRhdGEgdGhhdCB0aGUgZnVuY3Rpb24gcmV0dXJucyAwIGZvciBhcmUgZ3JvdXBlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5jb2x1bW4uZ3JvdXBpbmdDb21wYXJlciA9IChhOiBhbnksIGI6IGFueSkgPT4geyByZXR1cm4gYSA9PT0gYiA/IDAgOiAtMTsgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZ3JvdXBpbmdDb21wYXJlcihmdW5jUmVmOiAoYTogYW55LCBiOiBhbnkpID0+IG51bWJlcikge1xuICAgICAgICB0aGlzLl9ncm91cGluZ0NvbXBhcmVyID0gZnVuY1JlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBtaW5pbXVtIGB3aWR0aGAgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGRlZmF1bHRNaW5XaWR0aCA9ICB0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBkZWZhdWx0TWluV2lkdGgoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnODAnO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5ncmlkLmRpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvc3k6XG4gICAgICAgICAgICAgICAgcmV0dXJuICc2NCc7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICc1Nic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnODAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZWZlcmVuY2UgdG8gdGhlIGBpZ3gtZ3JpZGAgb3duZXIuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncmlkQ29tcG9uZW50ID0gdGhpcy5jb2x1bW4uZ3JpZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGdyaWQoKTogSWd4R3JpZEJhc2VEaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQVBJLmdyaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBib2R5VGVtcGxhdGVgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgYm9keVRlbXBsYXRlID0gdGhpcy5jb2x1bW4uYm9keVRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoJ2NlbGxUZW1wbGF0ZScpXG4gICAgZ2V0IGJvZHlUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9keSB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNib2R5VGVtcGxhdGUgaWd4Q2VsbCBsZXQtdmFsPlxuICAgICAqICAgIDxkaXYgc3R5bGUgPSBcImJhY2tncm91bmQtY29sb3I6IHllbGxvd2dyZWVuXCIgKGNsaWNrKSA9IFwiY2hhbmdlQ29sb3IodmFsKVwiPlxuICAgICAqICAgICAgIDxzcGFuPiB7e3ZhbH19IDwvc3Bhbj5cbiAgICAgKiAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2JvZHlUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiB0aGlzLmNvbHVtbi5ib2R5VGVtcGxhdGUgPSB0aGlzLmJvZHlUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgYm9keVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgdGVtcGxhdGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoZWFkZXJUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmhlYWRlclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIEBub3RpZnlDaGFuZ2VzKClcbiAgICBAV2F0Y2hDb2x1bW5DaGFuZ2VzKClcbiAgICBASW5wdXQoKVxuICAgIGdldCBoZWFkZXJUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlclRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWFkZXIgdGVtcGxhdGUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGhlaWdodCBpcyBmaXhlZCBhbmQgYW55IGNvbnRlbnQgYmlnZ2VyIHRoYW4gaXQgd2lsbCBiZSBjdXQgb2ZmLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI2hlYWRlclRlbXBsYXRlPlxuICAgICAqICAgPGRpdiBzdHlsZSA9IFwiYmFja2dyb3VuZC1jb2xvcjpibGFja1wiIChjbGljaykgPSBcImNoYW5nZUNvbG9yKHZhbClcIj5cbiAgICAgKiAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZFwiID57e2NvbHVtbi5maWVsZH19PC9zcGFuPlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIidoZWFkZXJUZW1wbGF0ZSdcIiwge3JlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgICogcHVibGljIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmhlYWRlclRlbXBsYXRlID0gdGhpcy5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgaGVhZGVyVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGlubGluZUVkaXRvclRlbXBsYXRlID0gdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXMoKVxuICAgIEBXYXRjaENvbHVtbkNoYW5nZXMoKVxuICAgIEBJbnB1dCgnY2VsbEVkaXRvclRlbXBsYXRlJylcbiAgICBnZXQgaW5saW5lRWRpdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5saW5lIGVkaXRvciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNpbmxpbmVFZGl0b3JUZW1wbGF0ZSBpZ3hDZWxsRWRpdG9yIGxldC1jZWxsPVwiY2VsbFwiPlxuICAgICAqICAgICA8aW5wdXQgdHlwZT1cInN0cmluZ1wiIFsobmdNb2RlbCldPVwiY2VsbC52YWx1ZVwiLz5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiJ2lubGluZUVkaXRvclRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgaW5saW5lRWRpdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgICogdGhpcy5jb2x1bW4uaW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmlubGluZUVkaXRvclRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBpbmxpbmVFZGl0b3JUZW1wbGF0ZSh0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICB0aGlzLl9pbmxpbmVFZGl0b3JUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgZmlsdGVyQ2VsbFRlbXBsYXRlYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBAbm90aWZ5Q2hhbmdlcygpXG4gICAgQFdhdGNoQ29sdW1uQ2hhbmdlcygpXG4gICAgQElucHV0KCdmaWx0ZXJDZWxsVGVtcGxhdGUnKVxuICAgIGdldCBmaWx0ZXJDZWxsVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsVGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1aWNrIGZpbHRlciB0ZW1wbGF0ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNmaWx0ZXJDZWxsVGVtcGxhdGUgSWd4RmlsdGVyQ2VsbFRlbXBsYXRlIGxldC1jb2x1bW49XCJjb2x1bW5cIj5cbiAgICAgKiAgICA8aW5wdXQgKGlucHV0KT1cIm9uSW5wdXQoKVwiPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCInZmlsdGVyQ2VsbFRlbXBsYXRlJ1wiLCB7cmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICAgKiBwdWJsaWMgZmlsdGVyQ2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgICAqIHRoaXMuY29sdW1uLmZpbHRlckNlbGxUZW1wbGF0ZSA9IHRoaXMuZmlsdGVyQ2VsbFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBmaWx0ZXJDZWxsVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2VsbHMgb2YgdGhlIGNvbHVtbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkNlbGxzID0gIHRoaXMuY29sdW1uLmNlbGxzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjZWxscygpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dMaXN0LmZpbHRlcigocm93KSA9PiByb3cgaW5zdGFuY2VvZiBJZ3hSb3dEaXJlY3RpdmUpXG4gICAgICAgICAgICAubWFwKChyb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmNlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuY2VsbHMuZmlsdGVyKChjZWxsKSA9PiBjZWxsLmNvbHVtbkluZGV4ID09PSB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiB2aXNpYmxlIGluZGV4LlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgbm90IHZpc2libGUsIHJldHVybnMgYC0xYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHZpc2libGVDb2x1bW5JbmRleCA9ICB0aGlzLmNvbHVtbi52aXNpYmxlSW5kZXg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHZpc2libGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgICBpZiAoIWlzTmFOKHRoaXMuX3ZJbmRleCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5waW5uZWRDb2x1bW5zID0gdGhpcy5ncmlkLnVucGlubmVkQ29sdW1ucy5maWx0ZXIoYyA9PiAhYy5jb2x1bW5Hcm91cCk7XG4gICAgICAgIGNvbnN0IHBpbm5lZENvbHVtbnMgPSB0aGlzLmdyaWQucGlubmVkQ29sdW1ucy5maWx0ZXIoYyA9PiAhYy5jb2x1bW5Hcm91cCk7XG4gICAgICAgIGxldCBjb2wgPSB0aGlzO1xuICAgICAgICBsZXQgdkluZGV4ID0gLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIGNvbCA9IHRoaXMuYWxsQ2hpbGRyZW4uZmlsdGVyKGMgPT4gIWMuY29sdW1uR3JvdXAgJiYgIWMuaGlkZGVuKVswXSBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlblZpc2libGVJbmRleGVzLmZpbmQoeCA9PiB4LmNvbHVtbiA9PT0gdGhpcykuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEluQ29sbGVjdGlvbiA9IHVucGlubmVkQ29sdW1ucy5pbmRleE9mKGNvbCk7XG4gICAgICAgICAgICB2SW5kZXggPSBpbmRleEluQ29sbGVjdGlvbiA9PT0gLTEgP1xuICAgICAgICAgICAgICAgIC0xIDpcbiAgICAgICAgICAgICAgICAodGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgP1xuICAgICAgICAgICAgICAgICAgICBwaW5uZWRDb2x1bW5zLmxlbmd0aCArIGluZGV4SW5Db2xsZWN0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhJbkNvbGxlY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhJbkNvbGxlY3Rpb24gPSBwaW5uZWRDb2x1bW5zLmluZGV4T2YoY29sKTtcbiAgICAgICAgICAgIHZJbmRleCA9IHRoaXMuZ3JpZC5pc1Bpbm5pbmdUb1N0YXJ0ID9cbiAgICAgICAgICAgICAgICBpbmRleEluQ29sbGVjdGlvbiA6XG4gICAgICAgICAgICAgICAgdW5waW5uZWRDb2x1bW5zLmxlbmd0aCArIGluZGV4SW5Db2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZJbmRleCA9IHZJbmRleDtcbiAgICAgICAgcmV0dXJuIHZJbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sdW1uIGlzIGEgYENvbHVtbkdyb3VwYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyb3VwID0gIHRoaXMuY29sdW1uLmNvbHVtbkdyb3VwO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5Hcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBgQ29sdW1uTGF5b3V0YCBmb3IgbXVsdGktcm93IGxheW91dC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbHVtbkdyb3VwID0gIHRoaXMuY29sdW1uLmNvbHVtbkdyb3VwO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5MYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2x1bW4gaXMgYSBjaGlsZCBvZiBhIGBDb2x1bW5MYXlvdXRgIGZvciBtdWx0aS1yb3cgbGF5b3V0LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTGF5b3V0Q2hpbGQgPSAgdGhpcy5jb2x1bW4uY29sdW1uTGF5b3V0Q2hpbGQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkxheW91dENoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY29sdW1uTGF5b3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoaWxkcmVuIGNvbHVtbnMgY29sbGVjdGlvbi5cbiAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZSBjb2x1bW4gZG9lcyBub3QgY29udGFpbiBjaGlsZHJlbiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY2hpbGRyZW5Db2x1bW5zID0gIHRoaXMuY29sdW1uLmFsbENoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBhbGxDaGlsZHJlbigpOiBJZ3hDb2x1bW5Db21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGV2ZWwgb2YgdGhlIGNvbHVtbiBpbiBhIGNvbHVtbiBncm91cC5cbiAgICAgKiBSZXR1cm5zIGAwYCBpZiB0aGUgY29sdW1uIGRvZXNuJ3QgaGF2ZSBhIGBwYXJlbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uTGV2ZWwgPSAgdGhpcy5jb2x1bW4ubGV2ZWw7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICBsZXQgcHRyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGxldCBsdmwgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgIGx2bCsrO1xuICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHZsO1xuICAgIH1cblxuICAgIGdldCBpc0xhc3RQaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCAmJlxuICAgICAgICAgICAgdGhpcy5ncmlkLnBpbm5lZENvbHVtbnNbdGhpcy5ncmlkLnBpbm5lZENvbHVtbnMubGVuZ3RoIC0gMV0gPT09IHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IGlzRmlyc3RQaW5uZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBpbm5lZENvbHMgPSB0aGlzLmdyaWQucGlubmVkQ29sdW1ucy5maWx0ZXIoeCA9PiAheC5jb2x1bW5Hcm91cCk7XG4gICAgICAgIHJldHVybiAhdGhpcy5ncmlkLmlzUGlubmluZ1RvU3RhcnQgJiYgcGlubmVkQ29sc1swXSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICBnZXQgcmlnaHRQaW5uZWRPZmZzZXQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlubmVkICYmICF0aGlzLmdyaWQuaXNQaW5uaW5nVG9TdGFydCA/XG4gICAgICAgICAgICAtIHRoaXMuZ3JpZC5waW5uZWRXaWR0aCAtIHRoaXMuZ3JpZC5oZWFkZXJGZWF0dXJlc1dpZHRoICsgJ3B4JyA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGdldCBncmlkUm93U3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFbmQgJiYgdGhpcy5yb3dTdGFydCA/IHRoaXMucm93RW5kIC0gdGhpcy5yb3dTdGFydCA6IDE7XG4gICAgfVxuICAgIGdldCBncmlkQ29sdW1uU3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xFbmQgJiYgdGhpcy5jb2xTdGFydCA/IHRoaXMuY29sRW5kIC0gdGhpcy5jb2xTdGFydCA6IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbHVtbiB3aWxsIGJlIHZpc2libGUgd2hlbiBpdHMgcGFyZW50IGlzIGNvbGxhcHNlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4tZ3JvdXA+XG4gICAgICogICA8aWd4LWNvbHVtbiBbdmlzaWJsZVdoZW5Db2xsYXBzZWRdPVwidHJ1ZVwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1jb2x1bW4tZ3JvdXA+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgQG5vdGlmeUNoYW5nZXModHJ1ZSlcbiAgICBASW5wdXQoKVxuICAgIHNldCB2aXNpYmxlV2hlbkNvbGxhcHNlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92aXNpYmxlV2hlbkNvbGxhcHNlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2libGVXaGVuQ29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5fdmlzaWJsZVdoZW5Db2xsYXBzZWQpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNldEV4cGFuZENvbGxhcHNlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB2aXNpYmxlV2hlbkNvbGxhcHNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVXaGVuQ29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGFzcyBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBEYXRlUGlwZSBhbmQvb3IgRGVjaW1hbFBpcGUgdG8gZm9ybWF0IHRoZSBkaXNwbGF5IHZhbHVlIGZvciBkYXRlIGFuZCBudW1lcmljIGNvbHVtbnMuXG4gICAgICogQWNjZXB0cyBhbiBgSUNvbHVtblBpcGVBcmdzYCBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIGBmb3JtYXRgLCBgdGltZXpvbmVgIGFuZCBgZGlnaXRzSW5mb2AgcHJvcGVydGllcy5cbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvbW1vbi9EYXRlUGlwZSBhbmQgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGVjaW1hbFBpcGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwaXBlQXJnczogSUNvbHVtblBpcGVBcmdzID0ge1xuICAgICAqICAgICAgZm9ybWF0OiAnbG9uZ0RhdGUnLFxuICAgICAqICAgICAgdGltZXpvbmU6ICdVVEMnLFxuICAgICAqICAgICAgZGlnaXRzSW5mbzogJzEuMS0yJ1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jb2x1bW4gZGF0YVR5cGU9XCJkYXRlXCIgW3BpcGVBcmdzXT1cInBpcGVBcmdzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDxpZ3gtY29sdW1uIGRhdGFUeXBlPVwibnVtYmVyXCIgW3BpcGVBcmdzXT1cInBpcGVBcmdzXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBwaXBlQXJncyh2YWx1ZTogSUNvbHVtblBpcGVBcmdzKSB7XG4gICAgICAgIHRoaXMuX2NvbHVtblBpcGVBcmdzID0gT2JqZWN0LmFzc2lnbih0aGlzLl9jb2x1bW5QaXBlQXJncywgdmFsdWUpO1xuICAgICAgICB0aGlzLmdyaWQuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgKHRoaXMuZ3JpZCBhcyBhbnkpLl9waXBlVHJpZ2dlcisrO1xuICAgICAgICB0aGlzLmdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cbiAgICBnZXQgcGlwZUFyZ3MoKTogSUNvbHVtblBpcGVBcmdzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtblBpcGVBcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbGxhcHNpYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgY29sbGFwc2libGUoX3ZhbHVlOiBib29sZWFuKSB7fVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGV4cGFuZGVkKF92YWx1ZTogYm9vbGVhbikge31cblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0V2lkdGg6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB3aWR0aFNldEJ5VXNlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaGFzTmVzdGVkUGF0aDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdHJlZSA9ICB0aGlzLmNvbHVtbi5maWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSgpOiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5maW5kKHRoaXMuZmllbGQpIGFzIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBwYXJlbnQgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgcGFyZW50Q29sdW1uID0gdGhpcy5jb2x1bW4ucGFyZW50O1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5wYXJlbnQgPSBoaWdoZXJMZXZlbENvbHVtbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGNoaWxkcmVuIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW5DaGlsZHJlbiA9IHRoaXMuY29sdW1uLmNoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNvbHVtbi5jaGlsZHJlbiA9IGNoaWxkcmVuQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hcHBseVNlbGVjdGFibGVDbGFzcyA9IGZhbHNlO1xuXG4gICAgcHJvdGVjdGVkIF92SW5kZXggPSBOYU47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcGlubmVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2hlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2lubGluZUVkaXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ZpbHRlckNlbGxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdW1tYXJpZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ZpbHRlcnMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3NvcnRTdHJhdGVneTogSVNvcnRpbmdTdHJhdGVneSA9IERlZmF1bHRTb3J0aW5nU3RyYXRlZ3kuaW5zdGFuY2UoKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0NvbXBhcmVyOiAoYTogYW55LCBiOiBhbnkpID0+IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oaWRkZW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9pbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rpc2FibGVQaW5uaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfd2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0TWluV2lkdGggPSAnJztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9oYXNTdW1tYXJ5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZWRpdGFibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Zpc2libGVXaGVuQ29sbGFwc2VkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NvbGxhcHNpYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZXhwYW5kZWQgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3NlbGVjdGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0IGlzUHJpbWFyeUNvbHVtbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdyaWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZpZWxkID09PSB0aGlzLmdyaWQucHJpbWFyeUtleTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9maWVsZDogc3RyaW5nO1xuICAgIHByaXZhdGUgX2NhbGNXaWR0aCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfY29sdW1uUGlwZUFyZ3M6IElDb2x1bW5QaXBlQXJncyA9IHsgZm9ybWF0OiBERUZBVUxUX0RBVEVfRk9STUFULCBkaWdpdHNJbmZvOiBERUZBVUxUX0RJR0lUU19JTkZPIH07XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+LCBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZikgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHJlc2V0Q2FjaGVzKCkge1xuICAgICAgICB0aGlzLl92SW5kZXggPSBOYU47XG4gICAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVDYWxjV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9ib2R5VGVtcGxhdGUgPSB0aGlzLmNlbGxUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFkVGVtcGxhdGUgJiYgdGhpcy5oZWFkVGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuaGVhZFRlbXBsYXRlLnRvQXJyYXkoKVswXS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW5saW5lRWRpdG9yVGVtcGxhdGUgPSB0aGlzLmVkaXRvclRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckNlbGxUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyQ2VsbFRlbXBsYXRlID0gdGhpcy5maWx0ZXJDZWxsVGVtcGxhdGVEaXJlY3RpdmUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1bW1hcmllcykge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneFN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLk51bWJlcjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hOdW1iZXJTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5EYXRlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneERhdGVTdW1tYXJ5T3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5DdXJyZW5jeTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdW1tYXJpZXMgPSBJZ3hDdXJyZW5jeVN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLlBlcmNlbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyaWVzID0gSWd4UGVyY2VudFN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcmllcyA9IElneFN1bW1hcnlPcGVyYW5kO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhVHlwZS5Cb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBJZ3hCb29sZWFuRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLk51bWJlcjpcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLkN1cnJlbmN5OlxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuUGVyY2VudDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gSWd4TnVtYmVyRmlsdGVyaW5nT3BlcmFuZC5pbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFUeXBlLkRhdGU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneERhdGVGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0R3JpZFRlbXBsYXRlKGlzUm93OiBib29sZWFuLCBpc0lFOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGlzUm93KSB7XG4gICAgICAgICAgICBjb25zdCByb3dzQ291bnQgPSB0aGlzLmdyaWQubXVsdGlSb3dMYXlvdXRSb3dTaXplO1xuICAgICAgICAgICAgcmV0dXJuIGlzSUUgP1xuICAgICAgICAgICAgICAgIGAoMWZyKVske3Jvd3NDb3VudH1dYCA6XG4gICAgICAgICAgICAgICAgYHJlcGVhdCgke3Jvd3NDb3VudH0sMWZyKWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5TaXplc1N0cmluZyh0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJbml0aWFsQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBBcnJheTxNUkxDb2x1bW5TaXplSW5mbz4ge1xuICAgICAgICBjb25zdCBjb2x1bW5TaXplczogTVJMQ29sdW1uU2l6ZUluZm9bXSA9IFtdO1xuICAgICAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBjb2wgc3BhbnNcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb2wuY29sU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aFNldCA9IGNvbC53aWR0aFNldEJ5VXNlciAmJiBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSAmJiAhY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0ud2lkdGhTZXRCeVVzZXI7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFuU21hbGxlciA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbFNwYW4gPiBjb2wuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICBjb25zdCBib3RoV2lkdGhzU2V0ID0gY29sLndpZHRoU2V0QnlVc2VyICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdICYmIGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuICAgICAgICAgICAgY29uc3QgYm90aFdpZHRoc05vdFNldCA9ICFjb2wud2lkdGhTZXRCeVVzZXIgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gJiYgIWNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLndpZHRoU2V0QnlVc2VyO1xuXG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgaXMgZGVmaW5lZCB5ZXQgdGFrZSBhbnkgY29sdW1uIGF0IGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIGNvbEVuZCB0byBrbm93IHdoZXJlIHRoZSBjb2x1bW4gYWN0dWFsbHkgZW5kcywgYmVjYXVzZSBub3QgYWx3YXlzIGl0IHN0YXJ0cyB3aGVyZSB3ZSBoYXZlIGl0IHNldCBpbiBjb2x1bW5TaXplcy5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1dpZHRoU2V0IHx8IChuZXdTcGFuU21hbGxlciAmJiAoKGJvdGhXaWR0aHNTZXQpIHx8IChib3RoV2lkdGhzTm90U2V0KSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjb2x1bW4gaXMgc2V0IGFscmVhZHkgaXQgc2hvdWxkIGVpdGhlciBub3QgaGF2ZSB3aWR0aCBkZWZpbmVkIG9yIGhhdmUgd2lkdGggd2l0aCBiaWdnZXIgc3BhbiB0aGFuIHRoZSBuZXcgb25lLlxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogIElmIHJlcGxhY2VkIGNvbHVtbiBoYXMgYmlnZ2VyIHNwYW4sIHdlIHdhbnQgdG8gZmlsbCB0aGUgcmVtYWluaW5nIGNvbHVtbnNcbiAgICAgICAgICAgICAgICAgKiAgdGhhdCB0aGUgcmVwbGFjaW5nIGNvbHVtbiBkb2VzIG5vdCBmaWxsIHdpdGggdGhlIG9sZCBvbmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGJvdGhXaWR0aHNTZXQgJiYgbmV3U3BhblNtYWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgbmV3IGNvbHVtbiBzZXQgd291bGQgZW5kIGFuZCBhcHBseSB0aGUgb2xkIGNvbHVtbiB0byB0aGUgcmVzdCBkZXBlbmRpbmcgb24gaG93IG11Y2ggaXQgc3BhbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm90IHlldCByZXBsYWNlZCBpdCBzbyB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5IGZyb20gdGhlIGNvbHVtblNpemVzIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29sRW5kIGlzIHVzZWQgYmVjYXVzZSB0aGUgY29sU3RhcnQgb2YgdGhlIG9sZCBjb2x1bW4gaXMgbm90IGFjdHVhbGx5IGkgKyAxLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSA8IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdLmNvbEVuZCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5TaXplc1tpXSB8fCAhY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IGNvbHVtblNpemVzW2NvbC5jb2xTdGFydCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCBjb2x1bW4gd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2wud2lkdGhTZXRCeVVzZXIgfHwgdGhpcy5ncmlkLmNvbHVtbldpZHRoU2V0QnlVc2VyID8gcGFyc2VJbnQoY29sLmNhbGNXaWR0aCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbC5jb2xTdGFydCArIGNvbC5ncmlkQ29sdW1uU3BhbixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhTZXRCeVVzZXI6IGNvbC53aWR0aFNldEJ5VXNlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvdGhXaWR0aHNTZXQgJiYgY29sdW1uU2l6ZXNbY29sLmNvbFN0YXJ0IC0gMV0uY29sU3BhbiA8IGNvbC5ncmlkQ29sdW1uU3Bhbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gYWxyZWFkeSBpbiB0aGUgY29sdW1uU2l6ZXMgaGFzIHNtYWxsZXIgc3Bhbiwgd2Ugc3RpbGwgbmVlZCB0byBmaWxsIGFueSBlbXB0eSBwbGFjZXMgd2l0aCB0aGUgY3VycmVudCBjb2wuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB3aGVyZSB0aGUgc21hbGxlciBjb2x1bW4gc2V0IHdvdWxkIGVuZCBhbmQgYXBwbHkgdGhlIGJpZ2dlciBjb2x1bW4gdG8gdGhlIHJlc3QgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIGl0IHNwYW5zLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGhlcmUgd2UgZG8gbm90IGhhdmUgaXQgaW4gY29sdW1uU2l6ZXMgd2Ugc2V0IGl0IGFzIGEgbmV3IGNvbHVtbiBrZWVwaW5nIHRoZSBzYW1lIGNvbFNwYW4uXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbC5jb2xTdGFydCAtIDEgKyBjb2x1bW5TaXplc1tjb2wuY29sU3RhcnQgLSAxXS5jb2xTcGFuOyBpIDwgY29sLmNvbFN0YXJ0IC0gMSArIGNvbC5ncmlkQ29sdW1uU3BhbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1uU2l6ZXNbaV0gfHwgIWNvbHVtblNpemVzW2ldLndpZHRoU2V0QnlVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sLndpZHRoU2V0QnlVc2VyIHx8IHRoaXMuZ3JpZC5jb2x1bW5XaWR0aFNldEJ5VXNlciA/IHBhcnNlSW50KGNvbC5jYWxjV2lkdGgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbEVuZDogY29sLmNvbFN0YXJ0ICsgY29sLmdyaWRDb2x1bW5TcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoU2V0QnlVc2VyOiBjb2wud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiBjb2x1bW5TaXplcyBzbyB0aGVyZSBhcmUgbm90IGNvbHVtbnMgd2l0aCBjb2xTcGFuID4gMVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaV0gJiYgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBlbXB0eSBwbGFjZXMgZGVwZW5kaW5nIG9uIGhvdyBtdWNoIHRoZSBjdXJyZW50IGNvbHVtbiBzcGFucyBzdGFydGluZyBmcm9tIG5leHQgY29sLlxuICAgICAgICAgICAgICAgIGZvciAoOyBqIDwgY29sdW1uU2l6ZXNbaV0uY29sU3BhbiAmJiBpICsgaiArIDEgPCBjb2x1bW5TaXplc1tpXS5jb2xFbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2l6ZXNbaSArIGpdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiBjb2x1bW5TaXplc1tpICsgal0ud2lkdGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjb2x1bW5TaXplc1tpXS53aWR0aCAmJiAhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCEhY29sdW1uU2l6ZXNbaSArIGpdLndpZHRoICYmIGNvbHVtblNpemVzW2kgKyBqXS5jb2xTcGFuIDw9IGNvbHVtblNpemVzW2ldLmNvbFNwYW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggYW4gYWxyZWFkeSBkZWZpbmVkIGNvbHVtbiB0aGF0IGhhcyB3aWR0aCBhbmQgdGhlIGN1cnJlbnQgZG9lc24ndCBoYXZlIG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVhY2hlZCBjb2x1bW4gaGFzIGJpZ2dlciBjb2xTcGFuIHdlIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TaXplc1tpICsgal0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBjb2x1bW5TaXplc1tpXS5yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sU3BhbjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xFbmQ6IGNvbHVtblNpemVzW2ldLmNvbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aFNldEJ5VXNlcjogY29sdW1uU2l6ZXNbaV0ud2lkdGhTZXRCeVVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY29sdW1uIHdpZHRoIHNvIGl0IGlzIGRpdmlkZWQgYmV0d2VlbiBhbGwgY29sdW1ucyBpdCBzcGFucyBhbmQgc2V0IGl0IHRvIDEuXG4gICAgICAgICAgICAgICAgY29sdW1uU2l6ZXNbaV0ud2lkdGggPSBjb2x1bW5TaXplc1tpXS53aWR0aFNldEJ5VXNlciA/XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoIC8gY29sdW1uU2l6ZXNbaV0uY29sU3BhbiA6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzW2ldLmNvbFNwYW4gPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbmRleCBiYXNlZCBvbiBob3cgbXVjaCB3ZSBoYXZlIHJlcGxhY2VkLiBTdWJ0cmFjdCAxIGJlY2F1c2Ugd2Ugc3RhcnRlZCBmcm9tIDEuXG4gICAgICAgICAgICAgICAgaSArPSBqIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2x1bW5TaXplcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RmlsbGVkQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4pOiBBcnJheTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKGNoaWxkcmVuKTtcblxuICAgICAgICAvLyBmaWxsIHRoZSBnYXBzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICAgICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpemUgb2YgY29sdW1uU2l6ZXMpIHtcbiAgICAgICAgICAgIGlmIChzaXplICYmICEhc2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNpemUud2lkdGggKyAncHgnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGhpcy5ncmlkLmdldFBvc3NpYmxlQ29sdW1uV2lkdGgoKSwgMTApICsgJ3B4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTogTVJMUmVzaXplQ29sdW1uSW5mb1tdIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0IHx8ICF0aGlzLmNvbHVtbkxheW91dENoaWxkIHx8IHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBbeyB0YXJnZXQ6IHRoaXMsIHNwYW5Vc2VkOiAxIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZWQgPSB0aGlzLmdldEluaXRpYWxDaGlsZENvbHVtblNpemVzKHRoaXMucGFyZW50LmNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0czogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGNvbnN0IGNvbEVuZCA9IHRoaXMuY29sRW5kID8gdGhpcy5jb2xFbmQgOiB0aGlzLmNvbFN0YXJ0ICsgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtblNpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xTdGFydCA8PSBpICsgMSAmJiBpICsgMSA8IGNvbEVuZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMucHVzaCh7IHRhcmdldDogY29sdW1uU2l6ZWRbaV0ucmVmLCBzcGFuVXNlZDogMSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldHNTcXVhc2hlZDogTVJMUmVzaXplQ29sdW1uSW5mb1tdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRzU3F1YXNoZWQubGVuZ3RoICYmIHRhcmdldHNTcXVhc2hlZFt0YXJnZXRzU3F1YXNoZWQubGVuZ3RoIC0gMV0udGFyZ2V0LmZpZWxkID09PSB0YXJnZXQudGFyZ2V0LmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0c1NxdWFzaGVkW3RhcmdldHNTcXVhc2hlZC5sZW5ndGggLSAxXS5zcGFuVXNlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzU3F1YXNoZWQucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldHNTcXVhc2hlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaW5zIHRoZSBjb2x1bW4gYXQgdGhlIHByb3ZpZGVkIGluZGV4IGluIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAgKiBEZWZhdWx0cyB0byBpbmRleCBgMGAgaWYgbm90IHByb3ZpZGVkLCBvciB0byB0aGUgaW5pdGlhbCBpbmRleCBpbiB0aGUgcGlubmVkIGFyZWEuXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyBzdWNjZXNzZnVsbHkgcGlubmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbHVtbiBjYW5ub3QgYmUgcGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgcGlubmVkIGlmOlxuICAgICAqIC0gSXMgYWxyZWFkeSBwaW5uZWRcbiAgICAgKiAtIGluZGV4IGFyZ3VtZW50IGlzIG91dCBvZiByYW5nZVxuICAgICAqIC0gVGhlIHBpbm5lZCBhcmVhIGV4Y2VlZHMgODAlIG9mIHRoZSBncmlkIHdpZHRoXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWNjZXNzID0gdGhpcy5jb2x1bW4ucGluKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHBpbihpbmRleD86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBvbGQgZnVuY3Rpb25zXG4gICAgICAgIC8vIHNob3VsZCBiZSBtb3ZlZCBhcyBhIGV2ZW50IHBhcmFtZXRlci5cbiAgICAgICAgY29uc3QgZ3JpZCA9ICh0aGlzLmdyaWQgYXMgYW55KTtcbiAgICAgICAgaWYgKHRoaXMuX3Bpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5waW5uZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExldmVsUGFyZW50LnBpbihpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNJbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChoYXNJbmRleCAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID4gZ3JpZC5waW5uZWRDb2x1bW5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgIXRoaXMucGlubmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3RQaW5uZWRDb2xzID0gZ3JpZC5fcGlubmVkQ29sdW1ucy5maWx0ZXIoKGMpID0+IGMubGV2ZWwgPT09IDApO1xuICAgICAgICBpbmRleCA9IGhhc0luZGV4ID8gaW5kZXggOiByb290UGlubmVkQ29scy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElQaW5Db2x1bW5DYW5jZWxsYWJsZUV2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IGZhbHNlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5vbkNvbHVtblBpbm5pbmcuZW1pdChhcmdzKTtcblxuICAgICAgICBpZiAoYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZW5kRWRpdChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fcGlubmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IGluZGV4IGlzIHRoZSBsYXN0IHBvc2l0aW9uLCBzbyB3aWxsIG5lZWQgdG8gZmluZCB0YXJnZXQgY29sdW1uIGJ5IFtpbmRleC0xXVxuICAgICAgICBjb25zdCB0YXJnZXRDb2x1bW4gPSBhcmdzLmluc2VydEF0SW5kZXggPT09IGdyaWQuX3Bpbm5lZENvbHVtbnMubGVuZ3RoID9cbiAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4IC0gMV0gOiBncmlkLl9waW5uZWRDb2x1bW5zW2FyZ3MuaW5zZXJ0QXRJbmRleF07XG5cbiAgICAgICAgaWYgKGdyaWQuX3Bpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghZ3JpZC5oYXNDb2x1bW5Hcm91cHMpIHtcbiAgICAgICAgICAgICAgICBncmlkLl9waW5uZWRDb2x1bW5zLnNwbGljZShhcmdzLmluc2VydEF0SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmFzZWQgb25seSBvbiByb290IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICByb290UGlubmVkQ29scy5zcGxpY2UoYXJncy5pbnNlcnRBdEluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBsZXQgYWxsUGlubmVkID0gW107XG4gICAgICAgICAgICAgICAgLy8gcmUtY3JlYXRlIGhpZXJhcmNoeVxuICAgICAgICAgICAgICAgIHJvb3RQaW5uZWRDb2xzLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhbGxQaW5uZWQucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbFBpbm5lZCA9IGFsbFBpbm5lZC5jb25jYXQoZ3JvdXAuYWxsQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQuX3Bpbm5lZENvbHVtbnMgPSBhbGxQaW5uZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkNvdW50ID0gdGhpcy5hbGxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZ3JpZC5fdW5waW5uZWRDb2x1bW5zLnNwbGljZShncmlkLl91bnBpbm5lZENvbHVtbnMuaW5kZXhPZih0aGlzKSwgMSArIGNoaWxkcmVuQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl9tb3ZlQ29sdW1ucyh0aGlzLCB0YXJnZXRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5waW4oKSk7XG4gICAgICAgICAgICBncmlkLnJlaW5pdFBpblN0YXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuICAgICAgICBncmlkLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5zLmZpbHRlcih4ID0+IHguY29sdW1uTGF5b3V0KS5mb3JFYWNoKHggPT4geC5wb3B1bGF0ZVZpc2libGVJbmRleGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JpZC5maWx0ZXJpbmdTZXJ2aWNlLnJlZnJlc2hFeHByZXNzaW9ucygpO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElQaW5Db2x1bW5FdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5jb2x1bW5QaW5uZWQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIHRoZSBjb2x1bW4gYW5kIHBsYWNlIGl0IGF0IHRoZSBwcm92aWRlZCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS5cbiAgICAgKiBEZWZhdWx0cyB0byBpbmRleCBgMGAgaWYgbm90IHByb3ZpZGVkLCBvciB0byB0aGUgaW5pdGlhbCBpbmRleCBpbiB0aGUgdW5waW5uZWQgYXJlYS5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sdW1uIGlzIHN1Y2Nlc3NmdWxseSB1bnBpbm5lZC4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb2x1bW4gY2Fubm90IGJlIHVucGlubmVkLlxuICAgICAqIENvbHVtbiBjYW5ub3QgYmUgdW5waW5uZWQgaWY6XG4gICAgICogLSBJcyBhbHJlYWR5IHVucGlubmVkXG4gICAgICogLSBpbmRleCBhcmd1bWVudCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHN1Y2Nlc3MgPSB0aGlzLmNvbHVtbi51bnBpbigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB1bnBpbihpbmRleD86IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBncmlkID0gKHRoaXMuZ3JpZCBhcyBhbnkpO1xuICAgICAgICBpZiAoIXRoaXMuX3Bpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBpbm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wTGV2ZWxQYXJlbnQudW5waW4oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0luZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGhhc0luZGV4ICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiBncmlkLl91bnBpbm5lZENvbHVtbnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXN0aW1hdGUgdGhlIGV4YWN0IGluZGV4IGF0IHdoaWNoIGNvbHVtbiB3aWxsIGJlIGluc2VydGVkXG4gICAgICAgIC8vIHRha2VzIGludG8gYWNjb3VudCBpbml0aWFsIHVucGlubmVkIGluZGV4IG9mIHRoZSBjb2x1bW5cbiAgICAgICAgaWYgKCFoYXNJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IGdyaWQudW5waW5uZWRDb2x1bW5zLm1hcChjb2wgPT4gY29sLmluZGV4KTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIGluZGljZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRpY2VzLmluZGV4T2YodGhpcy5pbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcmdzOiBJUGluQ29sdW1uQ2FuY2VsbGFibGVFdmVudEFyZ3MgPSB7IGNvbHVtbjogdGhpcywgaW5zZXJ0QXRJbmRleDogaW5kZXgsIGlzUGlubmVkOiB0cnVlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuZ3JpZC5vbkNvbHVtblBpbm5pbmcuZW1pdChhcmdzKTtcblxuICAgICAgICBpZiAoYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JpZC5lbmRFZGl0KGZhbHNlKTtcblxuICAgICAgICB0aGlzLl9waW5uZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5uZWRDaGFuZ2UuZW1pdCh0aGlzLl9waW5uZWQpO1xuXG4gICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgaW5kZXggaXMgdGhlIGxhc3QgcG9zaXRpb24sIHNvIHdpbGwgbmVlZCB0byBmaW5kIHRhcmdldCBjb2x1bW4gYnkgW2luZGV4LTFdXG4gICAgICAgIGNvbnN0IHRhcmdldENvbHVtbiA9IGFyZ3MuaW5zZXJ0QXRJbmRleCA9PT0gZ3JpZC5fdW5waW5uZWRDb2x1bW5zLmxlbmd0aCA/XG4gICAgICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4IC0gMV0gOiBncmlkLl91bnBpbm5lZENvbHVtbnNbYXJncy5pbnNlcnRBdEluZGV4XTtcblxuICAgICAgICBpZiAoIWhhc0luZGV4KSB7XG4gICAgICAgICAgICBncmlkLl91bnBpbm5lZENvbHVtbnMuc3BsaWNlKGluZGV4LCAwLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChncmlkLl9waW5uZWRDb2x1bW5zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5fcGlubmVkQ29sdW1ucy5zcGxpY2UoZ3JpZC5fcGlubmVkQ29sdW1ucy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJbmRleCkge1xuICAgICAgICAgICAgZ3JpZC5tb3ZlQ29sdW1uKHRoaXMsIHRhcmdldENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW5Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5hbGxDaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnVucGluKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZWluaXRQaW5TdGF0ZXMoKTtcbiAgICAgICAgZ3JpZC5yZXNldENhY2hlcygpO1xuXG4gICAgICAgIGdyaWQubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNvbHVtbnMuZmlsdGVyKHggPT4geC5jb2x1bW5MYXlvdXQpLmZvckVhY2goeCA9PiB4LnBvcHVsYXRlVmlzaWJsZUluZGV4ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmlkLmZpbHRlcmluZ1NlcnZpY2UucmVmcmVzaEV4cHJlc3Npb25zKCk7XG5cbiAgICAgICAgdGhpcy5ncmlkLmNvbHVtblBpbm5lZC5lbWl0KHsgY29sdW1uOiB0aGlzLCBpbnNlcnRBdEluZGV4OiBpbmRleCwgaXNQaW5uZWQ6IGZhbHNlIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY29sdW1uIHRvIHRoZSBzcGVjaWZpZWQgdmlzaWJsZSBpbmRleC5cbiAgICAgKiBJZiBwYXNzZWQgaW5kZXggaXMgaW52YWxpZCwgb3IgaWYgY29sdW1uIHdvdWxkIHJlY2VpdmUgYSBkaWZmZXJlbnQgdmlzaWJsZSBpbmRleCBhZnRlciBtb3ZpbmcsIG1vdmluZyBpcyBub3QgcGVyZm9ybWVkLlxuICAgICAqIElmIHBhc3NlZCBpbmRleCB3b3VsZCBtb3ZlIHRoZSBjb2x1bW4gdG8gYSBkaWZmZXJlbnQgY29sdW1uIGdyb3VwLiBtb3ZpbmcgaXMgbm90IHBlcmZvcm1lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbHVtbi5tb3ZlKGluZGV4KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIG1vdmUoaW5kZXg6IG51bWJlcikge1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBjb25zdCBncmlkID0gKHRoaXMuZ3JpZCBhcyBJZ3hHcmlkQmFzZURpcmVjdGl2ZSk7XG4gICAgICAgIGxldCBjb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQgfCBJZ3hDb2x1bW5Hcm91cENvbXBvbmVudD4gPSBncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy52aXNpYmxlSW5kZXggPiAtMSk7XG4gICAgICAgIC8vIGdyaWQgbGFzdCB2aXNpYmxlIGluZGV4XG4gICAgICAgIGNvbnN0IGxpID0gY29sdW1ucy5tYXAoYyA9PiBjLnZpc2libGVJbmRleCkucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1heChhLCBiKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBjb25zdCBpc1ByZWNlZGluZyA9IHRoaXMudmlzaWJsZUluZGV4IDwgaW5kZXg7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnZpc2libGVJbmRleCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBsaSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGMgPT4gYy5sZXZlbCA+PSB0aGlzLmxldmVsICYmIGMgIT09IHRoaXMgJiYgYy5wYXJlbnQgIT09IHRoaXMgJiZcbiAgICAgICAgICAgICAgICBjLnRvcExldmVsUGFyZW50ID09PSB0aGlzLnRvcExldmVsUGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgIC8vIElmIGlzUHJlY2VkaW5nLCBmaW5kIGEgdGFyZ2V0IHN1Y2ggdGhhdCB3aGVuIHRoZSBjdXJyZW50IGNvbHVtbiBpcyBwbGFjZWQgYWZ0ZXIgaXQsIGN1cnJlbnQgY29sdW1tbiB3aWxsIHJlY2VpdmUgYSB2aXNpYmxlSW5kZXggPT09IGluZGV4LiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB2aXNpYmxlIGNoaWxkcmVuIG9mIHRoZSBjb2x1bW5zLlxuICAgICAgICAvLyBJZiAhaXNQcmVjZWRpbmcsIGZpbmRzIGEgY29sdW1uIG9mIHRoZSBzYW1lIGxldmVsIGFuZCB2aXNpYmxlIGluZGV4IHRoYXQgZXF1YWxzIHRoZSBwYXNzZWQgaW5kZXggYWd1bWVudCAoYy52aXNpYmxlSW5kZXggPT09IGluZGV4KS4gTm8gbmVlZCB0byBjb25zaWRlciB0aGUgY2hpbGRyZW4gaGVyZS5cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgICAgIGlmIChpc1ByZWNlZGluZykge1xuICAgICAgICAgICAgY29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGMgPT4gYy52aXNpYmxlSW5kZXggPiB0aGlzLnZpc2libGVJbmRleCk7XG4gICAgICAgICAgICB0YXJnZXQgPSBjb2x1bW5zLmZpbmQoYyA9PiBjLmxldmVsID09PSB0aGlzLmxldmVsICYmIGMudmlzaWJsZUluZGV4ICsgYy5jYWxjQ2hpbGRyZW4oKSAtIHRoaXMuY2FsY0NoaWxkcmVuKCkgPT09IGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZUluZGV4IDwgdGhpcy52aXNpYmxlSW5kZXgpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gY29sdW1ucy5maW5kKGMgPT4gYy5sZXZlbCA9PT0gdGhpcy5sZXZlbCAmJiBjLnZpc2libGVJbmRleCA9PT0gaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgKHRhcmdldC5waW5uZWQgJiYgdGhpcy5kaXNhYmxlUGlubmluZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcyA9IGlzUHJlY2VkaW5nID8gRHJvcFBvc2l0aW9uLkFmdGVyRHJvcFRhcmdldCA6IERyb3BQb3NpdGlvbi5CZWZvcmVEcm9wVGFyZ2V0O1xuICAgICAgICBncmlkLm1vdmVDb2x1bW4odGhpcywgdGFyZ2V0IGFzIElneENvbHVtbkNvbXBvbmVudCwgcG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBObyBjaGlsZHJlbiBmb3IgdGhlIGNvbHVtbiwgc28gd2lsbCByZXR1cm5zIDEgb3IgMCwgaWYgdGhlIGNvbHVtbiBpcyBoaWRkZW4uXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGNDaGlsZHJlbigpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaGlkZGVuID8gMCA6IDE7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGNvbHVtbiB2aWJpc2lsaXR5IGFuZCBlbWl0cyB0aGUgcmVzcGVjdGl2ZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlVmlzaWJpbGl0eSh2YWx1ZT86IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA/PyAhdGhpcy5oaWRkZW47XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSUNvbHVtblZpc2liaWxpdHlDaGFuZ2luZ0V2ZW50QXJncyA9IHsgY29sdW1uOiB0aGlzLCBuZXdWYWx1ZSwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQuY29sdW1uVmlzaWJpbGl0eUNoYW5naW5nLmVtaXQoZXZlbnRBcmdzKTtcblxuICAgICAgICBpZiAoZXZlbnRBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZGVuID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuZ3JpZC5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2VkLmVtaXQoeyBjb2x1bW46IHRoaXMsIG5ld1ZhbHVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRvcCBsZXZlbCBwYXJlbnQgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdG9wTGV2ZWxQYXJlbnQgPSAgdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHRvcExldmVsUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBvZiB0aGUgY29sdW1uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogbGV0IGhlYWRlckNlbGwgPSBjb2x1bW4uaGVhZGVyQ2VsbDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyQ2VsbCgpOiBJZ3hHcmlkSGVhZGVyQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5oZWFkZXJDZWxsTGlzdC5maW5kKChoZWFkZXIpID0+IGhlYWRlci5jb2x1bW4gPT09IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBjZWxsIG9mIHRoZSBjb2x1bW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAgICAgKiBsZXQgZmlsdGVyZWxsID0gY29sdW1uLmZpbHRlcmVsbDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZmlsdGVyQ2VsbCgpOiBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZmlsdGVyQ2VsbExpc3QuZmluZCgoZmlsdGVyQ2VsbCkgPT4gZmlsdGVyQ2VsbC5jb2x1bW4gPT09IHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBncm91cCBvZiB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneENvbHVtbkNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBoZWFkZXJHcm91cCgpOiBJZ3hHcmlkSGVhZGVyR3JvdXBDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmhlYWRlckdyb3Vwc0xpc3QuZmluZCgoaGVhZGVyR3JvdXApID0+IGhlYWRlckdyb3VwLmNvbHVtbiA9PT0gdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemUgdGhlIGNvbHVtbiB0byB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKCdncmlkJykgZ3JpZDogSWd4R3JpZENvbXBvbmVudDtcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogY29sdW1uLmF1dG9zaXplKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q29sdW1uQ29tcG9uZW50XG4gICAgICogQHBhcmFtIGJ5SGVhZGVyIFNldCBpZiBjb2x1bW4gc2hvdWxkIGJlIGF1dGl6ZWQgYmFzZWQgb25seSBvbiB0aGUgaGVhZGVyIGNvbnRlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemUoYnlIZWFkZXIgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uR3JvdXApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldEF1dG9TaXplKGJ5SGVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnJlZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdXRvU2l6ZShieUhlYWRlciA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSAhYnlIZWFkZXIgPyB0aGlzLmdldExhcmdlc3RDZWxsV2lkdGgoKSA6XG4gICAgICAgICAgICAoT2JqZWN0LnZhbHVlcyh0aGlzLmdldEhlYWRlckNlbGxXaWR0aHMoKSkucmVkdWNlKChhLCBiKSA9PiBhICsgYikgKyAncHgnKTtcbiAgICAgICAgY29uc3QgZ3JpZEF2YWlsYWJsZVNpemUgPSB0aGlzLmdyaWQuY2FsY1dpZHRoO1xuICAgICAgICBsZXQgbmV3V2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gdGhpcy53aWR0aCAmJiB0eXBlb2YgdGhpcy53aWR0aCA9PT0gJ3N0cmluZycgJiYgdGhpcy53aWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2VTaXplID0gIHBhcnNlRmxvYXQoc2l6ZSkgLyBncmlkQXZhaWxhYmxlU2l6ZSAqIDEwMDtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gcGVyY2VudGFnZVNpemUgKyAnJSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1dpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2FsY1dpZHRoKCk6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxjV2lkdGggJiYgIWlzTmFOKHRoaXMuY2FsY1BpeGVsV2lkdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGVDYWxjV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGNXaWR0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBhbmQgcGFkZGluZyBvZiBhIGhlYWRlciBjZWxsLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRIZWFkZXJDZWxsV2lkdGhzKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBsZXQgaGVhZGVyV2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlclRlbXBsYXRlICYmIHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHRoaXMuaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgLm1hcCgoY2hpbGQpID0+IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNoaWxkKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCB0aGlzLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNvcnRhYmxlIHx8IHRoaXMuZmlsdGVyYWJsZSkge1xuICAgICAgICAgICAgaGVhZGVyV2lkdGggKz0gdGhpcy5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlblsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhlYWRlclN0eWxlID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGhlYWRlclBhZGRpbmcgPSBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoaGVhZGVyU3R5bGUucGFkZGluZ1JpZ2h0KSArXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGhlYWRlclN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuXG4gICAgICAgIC8vIFRha2UgaW50byBjb25zaWRlcmF0aW9uIHRoZSBoZWFkZXIgZ3JvdXAgZWxlbWVudCwgc2luY2UgY29sdW1uIHBpbm5pbmcgYXBwbGllcyBib3JkZXJzIHRvIGl0IGlmIGl0cyBub3QgYSBjb2x1bW5Hcm91cC5cbiAgICAgICAgY29uc3QgaGVhZGVyR3JvdXBTdHlsZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaGVhZGVyR3JvdXAuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgYm9yZGVyU2l6ZSA9ICF0aGlzLnBhcmVudCA/IHBhcnNlRmxvYXQoaGVhZGVyR3JvdXBTdHlsZS5ib3JkZXJSaWdodFdpZHRoKSArIHBhcnNlRmxvYXQoaGVhZGVyR3JvdXBTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIDogMDtcblxuICAgICAgICByZXR1cm4geyB3aWR0aDogTWF0aC5jZWlsKGhlYWRlcldpZHRoKSwgcGFkZGluZzogTWF0aC5jZWlsKGhlYWRlclBhZGRpbmcgKyBib3JkZXJTaXplKX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgdGhlIHNpemUgKGluIHBpeGVscykgb2YgdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZCgnZ3JpZCcpIGdyaWQ6IElneEdyaWRDb21wb25lbnQ7XG4gICAgICpcbiAgICAgKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gICAgICogbGV0IHNpemUgPSBjb2x1bW4uZ2V0TGFyZ2VzdENlbGxXaWR0aCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDb2x1bW5Db21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TGFyZ2VzdENlbGxXaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuZ3JpZC5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBjb25zdCBsYXJnZXN0ID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcblxuICAgICAgICBpZiAodGhpcy5jZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY2VsbHNDb250ZW50V2lkdGhzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5jZWxsc1swXS5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzLmZvckVhY2goKGNlbGwpID0+IGNlbGxzQ29udGVudFdpZHRocy5wdXNoKGNlbGwuY2FsY3VsYXRlU2l6ZVRvRml0KHJhbmdlKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsc0NvbnRlbnRXaWR0aHMgPSB0aGlzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY2VsbC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2VsbHNDb250ZW50V2lkdGhzLmluZGV4T2YoTWF0aC5tYXgoLi4uY2VsbHNDb250ZW50V2lkdGhzKSk7XG4gICAgICAgICAgICBjb25zdCBjZWxsU3R5bGUgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNlbGxzW2luZGV4XS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxQYWRkaW5nID0gcGFyc2VGbG9hdChjZWxsU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjZWxsU3R5bGUucGFkZGluZ1JpZ2h0KSArXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjZWxsU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSArIHBhcnNlRmxvYXQoY2VsbFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuXG4gICAgICAgICAgICBsYXJnZXN0LnNldChNYXRoLm1heCguLi5jZWxsc0NvbnRlbnRXaWR0aHMpLCBjZWxsUGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkZXJDZWxsKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJDZWxsV2lkdGhzID0gdGhpcy5nZXRIZWFkZXJDZWxsV2lkdGhzKCk7XG4gICAgICAgICAgICBsYXJnZXN0LnNldChoZWFkZXJDZWxsV2lkdGhzLndpZHRoLCBoZWFkZXJDZWxsV2lkdGhzLnBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFyZ2VzdENlbGwgPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKGxhcmdlc3Qua2V5cygpKSk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKGxhcmdlc3RDZWxsICsgbGFyZ2VzdC5nZXQobGFyZ2VzdENlbGwpKTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDZWxsV2lkdGgoKSB7XG4gICAgICAgIGNvbnN0IGNvbFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlV2lkdGggPSBjb2xXaWR0aCAmJiB0eXBlb2YgY29sV2lkdGggPT09ICdzdHJpbmcnICYmIGNvbFdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uTGF5b3V0Q2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2xXaWR0aCAmJiAhaXNQZXJjZW50YWdlV2lkdGgpIHtcblxuICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGNvbFdpZHRoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsV2lkdGggIT09ICdzdHJpbmcnIHx8IGNlbGxXaWR0aC5lbmRzV2l0aCgncHgnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKz0gJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNlbGxXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcG9wdWxhdGVWaXNpYmxlSW5kZXhlcygpIHsgfVxuXG4gICAgcHJvdGVjdGVkIGdldENvbHVtblNpemVzU3RyaW5nKGNoaWxkcmVuOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50Pik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZ2V0RmlsbGVkQ2hpbGRDb2x1bW5TaXplcyhjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiByZXMuam9pbignICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FjaGVDYWxjV2lkdGgoKTogYW55IHtcbiAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMuZ3JpZEFQSS5ncmlkO1xuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGlzUGVyY2VudGFnZVdpZHRoID0gY29sV2lkdGggJiYgdHlwZW9mIGNvbFdpZHRoID09PSAnc3RyaW5nJyAmJiBjb2xXaWR0aC5pbmRleE9mKCclJykgIT09IC0xO1xuICAgICAgICBpZiAoaXNQZXJjZW50YWdlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNXaWR0aCA9IHBhcnNlRmxvYXQoY29sV2lkdGgpIC8gMTAwICogZ3JpZC5jYWxjV2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBubyB3aWR0aFxuICAgICAgICAgICAgdGhpcy5fY2FsY1dpZHRoID0gdGhpcy5kZWZhdWx0V2lkdGggfHwgZ3JpZC5nZXRQb3NzaWJsZUNvbHVtbldpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjV2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsY1BpeGVsV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuX2NhbGNXaWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXRFeHBhbmRDb2xsYXBzZVN0YXRlKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZpbHRlcihjb2wgPT4gKGNvbC52aXNpYmxlV2hlbkNvbGxhcHNlZCAhPT0gdW5kZWZpbmVkKSkuZm9yRWFjaChjID0+ICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICBjLmhpZGRlbiA9IHRoaXMuaGlkZGVuOyByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLmhpZGRlbiA9IHRoaXMuX2V4cGFuZGVkID8gYy52aXNpYmxlV2hlbkNvbGxhcHNlZCA6ICFjLnZpc2libGVXaGVuQ29sbGFwc2VkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjaGVja0NvbGxhcHNpYmxlU3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbHMgPSB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpYmxlV2hlbkNvbGxhcHNlZCk7XG4gICAgICAgIHJldHVybiAoY29scy5zb21lKGMgPT4gYyA9PT0gdHJ1ZSkgJiYgY29scy5zb21lKGMgPT4gYyA9PT0gZmFsc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwaW5uYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyaWQgYXMgYW55KS5faW5pdCB8fCAhdGhpcy5waW5uZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYXBwbHlTZWxlY3RhYmxlQ2xhc3MoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNlbGVjdGFibGVDbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNldCBhcHBseVNlbGVjdGFibGVDbGFzcyh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVNlbGVjdGFibGVDbGFzcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19